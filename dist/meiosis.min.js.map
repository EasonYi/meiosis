{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///meiosis.min.js","webpack:///webpack/bootstrap 87fa879b0c550d518e19","webpack:///./src/index.ts","webpack:///./src/meiosis.ts","webpack:///./~/flyd/lib/index.js","webpack:///./~/ramda/src/curryN.js","webpack:///./~/ramda/src/internal/_arity.js","webpack:///./~/ramda/src/internal/_curry1.js","webpack:///./~/ramda/src/internal/_isPlaceholder.js","webpack:///./~/ramda/src/internal/_curry2.js","webpack:///./~/ramda/src/internal/_curryN.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__export","hasOwnProperty","newInstance","params","propose","flyd","stream","components","receives","map","getComponentFunctions","receive","fns","model","proposal","reduce","fn","scan","initialModel","states","stateFn","state","JSON","parse","stringify","combine","nexts","nextAction","forEach","on","prop","property","value","identity","filter","isFunction","obj","constructor","apply","trueFn","streams","i","s","deps","depEndStreams","endStream","createDependentStream","length","undefined","push","end","depsChanged","fnArgs","concat","listeners","addListeners","updateStream","boundMap","f","ap","s2","s1","self","val","streamToString","createStream","n","arguments","updateStreamValue","hasVal","vals","queued","of","toString","depsMet","shouldUpdate","initialDepsNotMet","every","inStream","toUpdate","returnVal","flushing","flushUpdate","updateDeps","o","list","findDeps","orderNextIdx","order","shift","then","markListeners","lists","removeListener","idx","indexOf","detachDeps","StreamTransformer","curryN","initialValue","isStream","immediate","endsOn","endS","acc","ns","merge","changed","transduce","xform","source","res","prototype","v","_arity","_curry1","_curry2","_curryN","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","Error","_isPlaceholder","f1","a","f2","b","_b","_a","received","combined","argsIdx","left","combinedIdx","result"],"mappings":"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","file":"meiosis.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar flyd = __webpack_require__(2);\n\tvar copy = function (obj) { return JSON.parse(JSON.stringify(obj)); };\n\tvar prop = function (property) { return function (value) { return value[property]; }; };\n\tvar identity = function (value) { return value; };\n\tvar getComponentFunctions = function (property) { return function (components) {\n\t    return components.map(prop(property)).filter(identity);\n\t}; };\n\tfunction newInstance(params) {\n\t    var propose = flyd.stream();\n\t    var components = flyd.stream([]);\n\t    var receives = flyd.map(getComponentFunctions(\"receive\"), components);\n\t    var receive = flyd.map(function (fns) { return function (model, proposal) {\n\t        return fns.reduce(function (model, fn) { return fn(model, proposal); }, model);\n\t    }; }, receives);\n\t    var model = flyd.scan(function (model, proposal) {\n\t        return receive()(model, proposal);\n\t    }, params.initialModel, propose);\n\t    var states = flyd.map(getComponentFunctions(\"state\"), components);\n\t    var stateFn = flyd.map(function (fns) { return function (model) {\n\t        return fns.reduce(function (state, fn) { return fn(model, state); }, JSON.parse(JSON.stringify(model)));\n\t    }; }, states);\n\t    var state = flyd.combine(function (model, stateFn) { return stateFn()(model()); }, [model, stateFn]);\n\t    var nexts = flyd.map(getComponentFunctions(\"nextAction\"), components);\n\t    var nextAction = flyd.map(function (fns) { return function (model, proposal) { return fns.forEach(function (fn) { return fn(model, proposal); }); }; }, nexts);\n\t    flyd.on(function (model) { return propose() && nextAction()(model, propose()); }, model);\n\t    return {\n\t        propose: propose,\n\t        components: components,\n\t        model: model,\n\t        stateFn: stateFn,\n\t        state: state\n\t    };\n\t}\n\texports.newInstance = newInstance;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar curryN = __webpack_require__(3);\n\t\n\t// Utility\n\tfunction isFunction(obj) {\n\t  return !!(obj && obj.constructor && obj.call && obj.apply);\n\t}\n\tfunction trueFn() { return true; }\n\t\n\t// Globals\n\tvar toUpdate = [];\n\tvar inStream;\n\tvar order = [];\n\tvar orderNextIdx = -1;\n\tvar flushing = false;\n\t\n\t/** @namespace */\n\tvar flyd = {}\n\t\n\t// /////////////////////////// API ///////////////////////////////// //\n\t\n\t/**\n\t * Creates a new stream\n\t *\n\t * __Signature__: `a -> Stream a`\n\t *\n\t * @name flyd.stream\n\t * @param {*} initialValue - (Optional) the initial value of the stream\n\t * @return {stream} the stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1); // Stream with initial value `1`\n\t * var s = flyd.stream(); // Stream with no initial value\n\t */\n\tflyd.stream = function(initialValue) {\n\t  var endStream = createDependentStream([], trueFn);\n\t  var s = createStream();\n\t  s.end = endStream;\n\t  s.fnArgs = [];\n\t  endStream.listeners.push(s);\n\t  if (arguments.length > 0) s(initialValue);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Create a new dependent stream\n\t *\n\t * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n\t *\n\t * @name flyd.combine\n\t * @param {Function} fn - the function used to combine the streams\n\t * @param {Array<stream>} dependencies - the streams that this one depends on\n\t * @return {stream} the dependent stream\n\t *\n\t * @example\n\t * var n1 = flyd.stream(0);\n\t * var n2 = flyd.stream(0);\n\t * var max = flyd.combine(function(n1, n2, self, changed) {\n\t *   return n1() > n2() ? n1() : n2();\n\t * }, [n1, n2]);\n\t */\n\tflyd.combine = curryN(2, combine);\n\tfunction combine(fn, streams) {\n\t  var i, s, deps, depEndStreams;\n\t  var endStream = createDependentStream([], trueFn);\n\t  deps = []; depEndStreams = [];\n\t  for (i = 0; i < streams.length; ++i) {\n\t    if (streams[i] !== undefined) {\n\t      deps.push(streams[i]);\n\t      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n\t    }\n\t  }\n\t  s = createDependentStream(deps, fn);\n\t  s.depsChanged = [];\n\t  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n\t  s.end = endStream;\n\t  endStream.listeners.push(s);\n\t  addListeners(depEndStreams, endStream);\n\t  endStream.deps = depEndStreams;\n\t  updateStream(s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n\t *\n\t * __Signature__: `* -> Boolean`\n\t *\n\t * @name flyd.isStream\n\t * @param {*} value - the value to test\n\t * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n\t *\n\t * @example\n\t * var s = flyd.stream(1);\n\t * var n = 1;\n\t * flyd.isStream(s); //=> true\n\t * flyd.isStream(n); //=> false\n\t */\n\tflyd.isStream = function(stream) {\n\t  return isFunction(stream) && 'hasVal' in stream;\n\t}\n\t\n\t/**\n\t * Invokes the body (the function to calculate the value) of a dependent stream\n\t *\n\t * By default the body of a dependent stream is only called when all the streams\n\t * upon which it depends has a value. `immediate` can circumvent this behaviour.\n\t * It immediately invokes the body of a dependent stream.\n\t *\n\t * __Signature__: `Stream a -> Stream a`\n\t *\n\t * @name flyd.immediate\n\t * @param {stream} stream - the dependent stream\n\t * @return {stream} the same stream\n\t *\n\t * @example\n\t * var s = flyd.stream();\n\t * var hasItems = flyd.immediate(flyd.combine(function(s) {\n\t *   return s() !== undefined && s().length > 0;\n\t * }, [s]);\n\t * console.log(hasItems()); // logs `false`. Had `immediate` not been\n\t *                          // used `hasItems()` would've returned `undefined`\n\t * s([1]);\n\t * console.log(hasItems()); // logs `true`.\n\t * s([]);\n\t * console.log(hasItems()); // logs `false`.\n\t */\n\tflyd.immediate = function(s) {\n\t  if (s.depsMet === false) {\n\t    s.depsMet = true;\n\t    updateStream(s);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t * Changes which `endsStream` should trigger the ending of `s`.\n\t *\n\t * __Signature__: `Stream a -> Stream b -> Stream b`\n\t *\n\t * @name flyd.endsOn\n\t * @param {stream} endStream - the stream to trigger the ending\n\t * @param {stream} stream - the stream to be ended by the endStream\n\t * @param {stream} the stream modified to be ended by endStream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var killer = flyd.stream();\n\t * // `double` ends when `n` ends or when `killer` emits any value\n\t * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n\t *   return 2 * n();\n\t * }, [n]);\n\t*/\n\tflyd.endsOn = function(endS, s) {\n\t  detachDeps(s.end);\n\t  endS.listeners.push(s.end);\n\t  s.end.deps.push(endS);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Map a stream\n\t *\n\t * Returns a new stream consisting of every value from `s` passed through\n\t * `fn`. I.e. `map` creates a new stream that listens to `s` and\n\t * applies `fn` to every new value.\n\t * __Signature__: `(a -> result) -> Stream a -> Stream result`\n\t *\n\t * @name flyd.map\n\t * @param {Function} fn - the function that produces the elements of the new stream\n\t * @param {stream} stream - the stream to map\n\t * @return {stream} a new stream with the mapped values\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n\t */\n\t// Library functions use self callback to accept (null, undefined) update triggers.\n\tflyd.map = curryN(2, function(f, s) {\n\t  return combine(function(s, self) { self(f(s.val)); }, [s]);\n\t})\n\t\n\t/**\n\t * Listen to stream events\n\t *\n\t * Similar to `map` except that the returned stream is empty. Use `on` for doing\n\t * side effects in reaction to stream changes. Use the returned stream only if you\n\t * need to manually end it.\n\t *\n\t * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n\t *\n\t * @name flyd.on\n\t * @param {Function} cb - the callback\n\t * @param {stream} stream - the stream\n\t * @return {stream} an empty stream (can be ended)\n\t */\n\tflyd.on = curryN(2, function(f, s) {\n\t  return combine(function(s) { f(s.val); }, [s]);\n\t})\n\t\n\t/**\n\t * Creates a new stream with the results of calling the function on every incoming\n\t * stream with and accumulator and the incoming value.\n\t *\n\t * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n\t *\n\t * @name flyd.scan\n\t * @param {Function} fn - the function to call\n\t * @param {*} val - the initial value of the accumulator\n\t * @param {stream} stream - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var numbers = flyd.stream();\n\t * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n\t * numbers(2)(3)(5);\n\t * sum(); // 10\n\t */\n\tflyd.scan = curryN(3, function(f, acc, s) {\n\t  var ns = combine(function(s, self) {\n\t    self(acc = f(acc, s.val));\n\t  }, [s]);\n\t  if (!ns.hasVal) ns(acc);\n\t  return ns;\n\t});\n\t\n\t/**\n\t * Creates a new stream down which all values from both `stream1` and `stream2`\n\t * will be sent.\n\t *\n\t * __Signature__: `Stream a -> Stream a -> Stream a`\n\t *\n\t * @name flyd.merge\n\t * @param {stream} source1 - one stream to be merged\n\t * @param {stream} source2 - the other stream to be merged\n\t * @return {stream} a stream with the values from both sources\n\t *\n\t * @example\n\t * var btn1Clicks = flyd.stream();\n\t * button1Elm.addEventListener(btn1Clicks);\n\t * var btn2Clicks = flyd.stream();\n\t * button2Elm.addEventListener(btn2Clicks);\n\t * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n\t */\n\tflyd.merge = curryN(2, function(s1, s2) {\n\t  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n\t    if (changed[0]) {\n\t      self(changed[0]());\n\t    } else if (s1.hasVal) {\n\t      self(s1.val);\n\t    } else if (s2.hasVal) {\n\t      self(s2.val);\n\t    }\n\t  }, [s1, s2]));\n\t  flyd.endsOn(combine(function() {\n\t    return true;\n\t  }, [s1.end, s2.end]), s);\n\t  return s;\n\t});\n\t\n\t/**\n\t * Creates a new stream resulting from applying `transducer` to `stream`.\n\t *\n\t * __Signature__: `Transducer -> Stream a -> Stream b`\n\t *\n\t * @name flyd.transduce\n\t * @param {Transducer} xform - the transducer transformation\n\t * @param {stream} source - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var t = require('transducers.js');\n\t *\n\t * var results = [];\n\t * var s1 = flyd.stream();\n\t * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n\t * var s2 = flyd.transduce(tx, s1);\n\t * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n\t * s1(1)(1)(2)(3)(3)(3)(4);\n\t * results; // => [2, 4, 6, 8]\n\t */\n\tflyd.transduce = curryN(2, function(xform, source) {\n\t  xform = xform(new StreamTransformer());\n\t  return combine(function(source, self) {\n\t    var res = xform['@@transducer/step'](undefined, source.val);\n\t    if (res && res['@@transducer/reduced'] === true) {\n\t      self.end(true);\n\t      return res['@@transducer/value'];\n\t    } else {\n\t      return res;\n\t    }\n\t  }, [source]);\n\t});\n\t\n\t/**\n\t * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n\t * modules for Flyd.\n\t *\n\t * @name flyd.curryN\n\t * @function\n\t * @param {Integer} arity - the function arity\n\t * @param {Function} fn - the function to curry\n\t * @return {Function} the curried function\n\t *\n\t * @example\n\t * function add(x, y) { return x + y; };\n\t * var a = flyd.curryN(2, add);\n\t * a(2)(4) // => 6\n\t */\n\tflyd.curryN = curryN\n\t\n\t/**\n\t * Returns a new stream identical to the original except every\n\t * value will be passed through `f`.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n\t *\n\t * @name stream.map\n\t * @param {Function} function - the function to apply\n\t * @return {stream} a new stream with the values mapped\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = numbers.map(function(n) { return n*n; });\n\t */\n\tfunction boundMap(f) { return flyd.map(f, this); }\n\t\n\t/**\n\t * Returns a new stream which is the result of applying the\n\t * functions from `this` stream to the values in `stream` parameter.\n\t *\n\t * `this` stream must be a stream of functions.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n\t *\n\t * @name stream.ap\n\t * @param {stream} stream - the values stream\n\t * @return {stream} a new stram with the functions applied to values\n\t *\n\t * @example\n\t * var add = flyd.curryN(2, function(x, y) { return x + y; });\n\t * var numbers1 = flyd.stream();\n\t * var numbers2 = flyd.stream();\n\t * var addToNumbers1 = flyd.map(add, numbers1);\n\t * var added = addToNumbers1.ap(numbers2);\n\t */\n\tfunction ap(s2) {\n\t  var s1 = this;\n\t  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n\t}\n\t\n\t/**\n\t * Get a human readable view of a stream\n\t * @name stream.toString\n\t * @return {String} the stream string representation\n\t */\n\tfunction streamToString() {\n\t  return 'stream(' + this.val + ')';\n\t}\n\t\n\t/**\n\t * @name stream.end\n\t * @memberof stream\n\t * A stream that emits `true` when the stream ends. If `true` is pushed down the\n\t * stream the parent stream ends.\n\t */\n\t\n\t/**\n\t * @name stream.of\n\t * @function\n\t * @memberof stream\n\t * Returns a new stream with `value` as its initial value. It is identical to\n\t * calling `flyd.stream` with one argument.\n\t *\n\t * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n\t *\n\t * @param {*} value - the initial value\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var m = n.of(1);\n\t */\n\t\n\t// /////////////////////////// PRIVATE ///////////////////////////////// //\n\t/**\n\t * @private\n\t * Create a stream with no dependencies and no value\n\t * @return {Function} a flyd stream\n\t */\n\tfunction createStream() {\n\t  function s(n) {\n\t    if (arguments.length === 0) return s.val\n\t    updateStreamValue(s, n)\n\t    return s\n\t  }\n\t  s.hasVal = false;\n\t  s.val = undefined;\n\t  s.vals = [];\n\t  s.listeners = [];\n\t  s.queued = false;\n\t  s.end = undefined;\n\t  s.map = boundMap;\n\t  s.ap = ap;\n\t  s.of = flyd.stream;\n\t  s.toString = streamToString;\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Create a dependent stream\n\t * @param {Array<stream>} dependencies - an array of the streams\n\t * @param {Function} fn - the function used to calculate the new stream value\n\t * from the dependencies\n\t * @return {stream} the created stream\n\t */\n\tfunction createDependentStream(deps, fn) {\n\t  var s = createStream();\n\t  s.fn = fn;\n\t  s.deps = deps;\n\t  s.depsMet = false;\n\t  s.depsChanged = deps.length > 0 ? [] : undefined;\n\t  s.shouldUpdate = false;\n\t  addListeners(deps, s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Check if all the dependencies have values\n\t * @param {stream} stream - the stream to check depencencies from\n\t * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n\t */\n\tfunction initialDepsNotMet(stream) {\n\t  stream.depsMet = stream.deps.every(function(s) {\n\t    return s.hasVal;\n\t  });\n\t  return !stream.depsMet;\n\t}\n\t\n\t/**\n\t * @private\n\t * Update a dependent stream using its dependencies in an atomic way\n\t * @param {stream} stream - the stream to update\n\t */\n\tfunction updateStream(s) {\n\t  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n\t      (s.end !== undefined && s.end.val === true)) return;\n\t  if (inStream !== undefined) {\n\t    toUpdate.push(s);\n\t    return;\n\t  }\n\t  inStream = s;\n\t  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n\t  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n\t  if (returnVal !== undefined) {\n\t    s(returnVal);\n\t  }\n\t  inStream = undefined;\n\t  if (s.depsChanged !== undefined) s.depsChanged = [];\n\t  s.shouldUpdate = false;\n\t  if (flushing === false) flushUpdate();\n\t}\n\t\n\t/**\n\t * @private\n\t * Update the dependencies of a stream\n\t * @param {stream} stream\n\t */\n\tfunction updateDeps(s) {\n\t  var i, o, list\n\t  var listeners = s.listeners;\n\t  for (i = 0; i < listeners.length; ++i) {\n\t    list = listeners[i];\n\t    if (list.end === s) {\n\t      endStream(list);\n\t    } else {\n\t      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n\t      list.shouldUpdate = true;\n\t      findDeps(list);\n\t    }\n\t  }\n\t  for (; orderNextIdx >= 0; --orderNextIdx) {\n\t    o = order[orderNextIdx];\n\t    if (o.shouldUpdate === true) updateStream(o);\n\t    o.queued = false;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add stream dependencies to the global `order` queue.\n\t * @param {stream} stream\n\t * @see updateDeps\n\t */\n\tfunction findDeps(s) {\n\t  var i\n\t  var listeners = s.listeners;\n\t  if (s.queued === false) {\n\t    s.queued = true;\n\t    for (i = 0; i < listeners.length; ++i) {\n\t      findDeps(listeners[i]);\n\t    }\n\t    order[++orderNextIdx] = s;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction flushUpdate() {\n\t  flushing = true;\n\t  while (toUpdate.length > 0) {\n\t    var s = toUpdate.shift();\n\t    if (s.vals.length > 0) s.val = s.vals.shift();\n\t    updateDeps(s);\n\t  }\n\t  flushing = false;\n\t}\n\t\n\t/**\n\t * @private\n\t * Push down a value into a stream\n\t * @param {stream} stream\n\t * @param {*} value\n\t */\n\tfunction updateStreamValue(s, n) {\n\t  if (n !== undefined && n !== null && isFunction(n.then)) {\n\t    n.then(s);\n\t    return;\n\t  }\n\t  s.val = n;\n\t  s.hasVal = true;\n\t  if (inStream === undefined) {\n\t    flushing = true;\n\t    updateDeps(s);\n\t    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n\t  } else if (inStream === s) {\n\t    markListeners(s, s.listeners);\n\t  } else {\n\t    s.vals.push(n);\n\t    toUpdate.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction markListeners(s, lists) {\n\t  var i, list;\n\t  for (i = 0; i < lists.length; ++i) {\n\t    list = lists[i];\n\t    if (list.end !== s) {\n\t      if (list.depsChanged !== undefined) {\n\t        list.depsChanged.push(s);\n\t      }\n\t      list.shouldUpdate = true;\n\t    } else {\n\t      endStream(list);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add dependencies to a stream\n\t * @param {Array<stream>} dependencies\n\t * @param {stream} stream\n\t */\n\tfunction addListeners(deps, s) {\n\t  for (var i = 0; i < deps.length; ++i) {\n\t    deps[i].listeners.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Removes an stream from a dependency array\n\t * @param {stream} stream\n\t * @param {Array<stream>} dependencies\n\t */\n\tfunction removeListener(s, listeners) {\n\t  var idx = listeners.indexOf(s);\n\t  listeners[idx] = listeners[listeners.length - 1];\n\t  listeners.length--;\n\t}\n\t\n\t/**\n\t * @private\n\t * Detach a stream from its dependencies\n\t * @param {stream} stream\n\t */\n\tfunction detachDeps(s) {\n\t  for (var i = 0; i < s.deps.length; ++i) {\n\t    removeListener(s, s.deps[i].listeners);\n\t  }\n\t  s.deps.length = 0;\n\t}\n\t\n\t/**\n\t * @private\n\t * Ends a stream\n\t */\n\tfunction endStream(s) {\n\t  if (s.deps !== undefined) detachDeps(s);\n\t  if (s.end !== undefined) detachDeps(s.end);\n\t}\n\t\n\t/**\n\t * @private\n\t * transducer stream transformer\n\t */\n\tfunction StreamTransformer() { }\n\tStreamTransformer.prototype['@@transducer/init'] = function() { };\n\tStreamTransformer.prototype['@@transducer/result'] = function() { };\n\tStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\t\n\tmodule.exports = flyd;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _curry1 = __webpack_require__(5);\n\tvar _curry2 = __webpack_require__(7);\n\tvar _curryN = __webpack_require__(8);\n\t\n\t\n\t/**\n\t * Returns a curried equivalent of the provided function, with the specified\n\t * arity. The curried function has two unusual capabilities. First, its\n\t * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1)(2)(3)`\n\t *   - `g(1)(2, 3)`\n\t *   - `g(1, 2)(3)`\n\t *   - `g(1, 2, 3)`\n\t *\n\t * Secondly, the special placeholder value `R.__` may be used to specify\n\t * \"gaps\", allowing partial application of any combination of arguments,\n\t * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1, 2, 3)`\n\t *   - `g(_, 2, 3)(1)`\n\t *   - `g(_, _, 3)(1)(2)`\n\t *   - `g(_, _, 3)(1, 2)`\n\t *   - `g(_, 2)(1)(3)`\n\t *   - `g(_, 2)(1, 3)`\n\t *   - `g(_, 2)(_, 3)(1)`\n\t *\n\t * @func\n\t * @memberOf R\n\t * @since v0.5.0\n\t * @category Function\n\t * @sig Number -> (* -> a) -> (* -> a)\n\t * @param {Number} length The arity for the returned function.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} A new, curried function.\n\t * @see R.curry\n\t * @example\n\t *\n\t *      var sumArgs = (...args) => R.sum(args);\n\t *\n\t *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n\t *      var f = curriedAddFourNumbers(1, 2);\n\t *      var g = f(3);\n\t *      g(4); //=> 10\n\t */\n\tmodule.exports = _curry2(function curryN(length, fn) {\n\t  if (length === 1) {\n\t    return _curry1(fn);\n\t  }\n\t  return _arity(length, _curryN(length, [], fn));\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _arity(n, fn) {\n\t  /* eslint-disable no-unused-vars */\n\t  switch (n) {\n\t    case 0: return function() { return fn.apply(this, arguments); };\n\t    case 1: return function(a0) { return fn.apply(this, arguments); };\n\t    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n\t    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n\t    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n\t    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n\t    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n\t    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n\t    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n\t    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n\t    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n\t    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n\t  }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal one-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry1(fn) {\n\t  return function f1(a) {\n\t    if (arguments.length === 0 || _isPlaceholder(a)) {\n\t      return f1;\n\t    } else {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _isPlaceholder(a) {\n\t  return a != null &&\n\t         typeof a === 'object' &&\n\t         a['@@functional/placeholder'] === true;\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _curry1 = __webpack_require__(5);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal two-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry2(fn) {\n\t  return function f2(a, b) {\n\t    switch (arguments.length) {\n\t      case 0:\n\t        return f2;\n\t      case 1:\n\t        return _isPlaceholder(a) ? f2\n\t             : _curry1(function(_b) { return fn(a, _b); });\n\t      default:\n\t        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n\t             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n\t             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n\t             : fn(a, b);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Internal curryN function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Number} length The arity of the curried function.\n\t * @param {Array} received An array of arguments received thus far.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curryN(length, received, fn) {\n\t  return function() {\n\t    var combined = [];\n\t    var argsIdx = 0;\n\t    var left = length;\n\t    var combinedIdx = 0;\n\t    while (combinedIdx < received.length || argsIdx < arguments.length) {\n\t      var result;\n\t      if (combinedIdx < received.length &&\n\t          (!_isPlaceholder(received[combinedIdx]) ||\n\t           argsIdx >= arguments.length)) {\n\t        result = received[combinedIdx];\n\t      } else {\n\t        result = arguments[argsIdx];\n\t        argsIdx += 1;\n\t      }\n\t      combined[combinedIdx] = result;\n\t      if (!_isPlaceholder(result)) {\n\t        left -= 1;\n\t      }\n\t      combinedIdx += 1;\n\t    }\n\t    return left <= 0 ? fn.apply(this, combined)\n\t                     : _arity(left, _curryN(length, combined, fn));\n\t  };\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// meiosis.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 87fa879b0c550d518e19","export * from \"./meiosis\";\nexport * from \"./component\";\nexport * from \"./nextAction\";\nexport * from \"./receive\";\nexport * from \"./state\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as flyd from \"flyd\";\nimport { Component } from \"./component\";\nimport { Receive } from \"./receive\";\nimport { ComponentState, State } from \"./state\";\nimport { NextAction } from \"./nextAction\";\n\ntype Stream<T> = Flyd.Stream<T>;\n\nexport interface InstanceParameters<M> {\n  initialModel: M;\n}\n\nexport interface MeiosisApp<M, P, S> {\n  propose: Flyd.Stream<P>;\n  components: Flyd.Stream<Array<Component<M, P, S>>>;\n  model: Flyd.Stream<M>;\n  stateFn: Flyd.Stream<State<M, S>>;\n  state: Flyd.Stream<S>;\n}\n\nconst copy = (obj: any): any => JSON.parse(JSON.stringify(obj));\nconst prop = (property: string) => (value: any) => value[property];\nconst identity = <T>(value: T) => value;\n\nconst getComponentFunctions = <M, P, S>(property: string) => (components: Array<Component<M, P, S>>) =>\n  components.map(prop(property)).filter(identity);\n\nfunction newInstance<M, P, S>(params: InstanceParameters<M>): MeiosisApp<M, P, S> {\n  const propose: Stream<P> = flyd.stream<P>();\n  const components: Stream<Array<Component<M, P, S>>> = flyd.stream<Array<Component<M, P, S>>>([]);\n\n  const receives = flyd.map(getComponentFunctions(\"receive\"), components);\n  const receive = flyd.map(fns => (model: M, proposal: P) =>\n    fns.reduce((model, fn) => fn(model, proposal), model), receives);\n\n  const model: Stream<M> = flyd.scan<P, M>((model: M, proposal: P) =>\n    receive()(model, proposal), params.initialModel, propose);\n\n  const states: Stream<Array<State<M, S>>> = flyd.map<Array<Component<M, P, S>>, Array<State<M, S>>>(\n    getComponentFunctions(\"state\"), components);\n\n  const stateFn: Stream<State<M, S>> = flyd.map<Array<ComponentState<M, S>>, State<M, S>>(fns => (model: M) =>\n    fns.reduce((state, fn) => fn(model, state), JSON.parse(JSON.stringify(model))), states);\n\n  const state: Stream<S> = flyd.combine<M, State<M, S>, S>(\n    (model: Stream<M>, stateFn: Stream<State<M, S>>) => stateFn()(model()),\n    [model, stateFn]);\n\n  const nexts: Stream<Array<NextAction<M, P>>> = flyd.map<Array<Component<M, P, S>>, Array<NextAction<M, P>>>(\n    getComponentFunctions(\"nextAction\"), components);\n\n  const nextAction: Stream<NextAction<M, P>> = flyd.map<Array<NextAction<M, P>>, NextAction<M, P>>(\n    fns => (model: M, proposal: P) => fns.forEach(fn => fn(model, proposal)), nexts);\n\n  flyd.on(model => propose() && nextAction()(model, propose()), model);\n\n  return {\n    propose,\n    components,\n    model,\n    stateFn,\n    state\n  };\n}\n\nexport {\n  newInstance,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/meiosis.ts","'use strict';\n\nvar curryN = require('ramda/src/curryN');\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stram with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/flyd/lib/index.js\n// module id = 2\n// module chunks = 0","var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _curry2 = require('./internal/_curry2');\nvar _curryN = require('./internal/_curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/curryN.js\n// module id = 3\n// module chunks = 0","module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_arity.js\n// module id = 4\n// module chunks = 0","var _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry1.js\n// module id = 5\n// module chunks = 0","module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_isPlaceholder.js\n// module id = 6\n// module chunks = 0","var _curry1 = require('./_curry1');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry2.js\n// module id = 7\n// module chunks = 0","var _arity = require('./_arity');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curryN.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}