{"version":3,"sources":["webpack:///meiosis.min.js","webpack:///webpack/bootstrap 9e9529f28e32bde1846f","webpack:///./src/index.ts","webpack:///./src/meiosis.ts","webpack:///./src/merge.ts","webpack:///./src/wire.ts"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","meiosis_1","Object","defineProperty","value","meiosis","merge_1","wire_1","adapters","allReceivers","wire","defaultWire","rootWire","merge","defaultMerge","rootModel","createComponent","config","view","Error","initialModel","componentWire","next","emit","nextAction","actions","receivers","Array","constructor","prototype","push","apply","listen","update","updateTr","transform","forEach","receiver","chain","props","run","root","length","renderRoot","model","render","target","sources","_i","arguments","undefined","TypeError","output","index","source","nextKey","hasOwnProperty","wires","nextWireId","createWire","listener","lstnr","data","wireName","name","theWire"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAH,WACAK,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,QAAA,EAGAP,EAAAC,QAvBA,GAAAI,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDOM,SAASH,EAAQC,EAASE,GAE/B,YE/CD,IAAAS,GAAAT,EAAwB,EAExBU,QAAAC,eAAAb,EAAA,cAAAc,OAAA,IFgDCd,aEhDcW,EAAAI,SFqDT,SAAShB,EAAQC,EAASE,GAE/B,YGvDD,IAAAc,GAAAd,EAAqC,GAErCe,EAAAf,EAAkE,GAkB5Da,EAAU,SAACG,GACf,GAAIC,MAEEC,EAAoBF,EAASE,MAAQH,EAAAI,YACrCC,EAAWF,EAAK,WAEhBG,EAAgBL,EAASK,OAASP,EAAAQ,aAEpCC,KAEEC,EAAkB,SAACC,GACvB,IAAKA,IAAWA,EAAOC,KACrB,KAAM,IAAIC,OAAM,kEAElBJ,GAAYF,EAAME,EAAWE,EAAOG,iBAEpC,IAAMC,GAAsBX,IACtBY,EAAgBD,EAAcE,KAC9BC,GAAcF,QACdG,EAAUR,EAAOQ,QAAUZ,EAAMW,EAAYP,EAAOQ,QAAQH,IAASE,EAErEE,EAA6BT,EAAOS,SAoB1C,OAnBIA,IAAaC,QAAUD,EAAUE,aACnCD,MAAME,UAAUC,KAAKC,MAAMtB,EAAciB,GAG3CL,EAAcW,OAAO,SAACC,GACpB,GAAMC,GAAgBjB,EAAOkB,UAAYlB,EAAOkB,UAAUpB,EAAWkB,GAAUA,CAE/ExB,GAAa2B,QAAQ,SAACC,GAEpB,MADAtB,GAAYsB,EAAStB,EAAWmB,KAIlCtB,EAASW,KAAKR,GAEVE,EAAOqB,OACTrB,EAAOqB,MAAML,EAAQR,KAIlB,SAACc,GAAe,MAAAtB,GAAOC,KAAKL,KAAU0B,GAAQd,eAGjDe,EAAM,SAACC,GACiB,IAAxBhC,EAAaiC,QACfjC,EAAaqB,KAAKjB,EAEpB,IAAM8B,GAAa,SAACC,GAAiBpC,EAASqC,OAAOJ,GAAOG,WAK5D,OAJAhC,GAASoB,OAAOW,GAEhB/B,EAASW,KAAKR,GAEP4B,EAGT,QAAS3B,kBAAiBwB,OAGnBlD,GAAAe,QAAOA,GH2BV,SAAShB,EAAQC,GAEtB,YI1GD,IAAMwB,GAAuB,SAASgC,GJ6GjC,II7G8C,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAP,OAAAM,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EACjD,IAAeE,SAAXJ,GAAmC,OAAXA,EAC1B,KAAM,IAAIK,WAAU,6CAItB,KAAK,GADDC,GAASlD,OAAO4C,GACXO,EAAQ,EAAGA,EAAQJ,UAAUP,OAAQW,IAAS,CACrD,GAAMC,GAASL,UAAUI,EACzB,IAAeH,SAAXI,GAAmC,OAAXA,EAC1B,IAAK,GAAIC,KAAWD,GACdA,EAAOE,eAAeD,KACxBH,EAAOG,GAAWD,EAAOC,IAKjC,MAAOH,GAGQ9D,GAAAwB,aAAYA,GJkHvB,SAASzB,EAAQC,GAEtB,YK1HD,IAAMqB,GAA2B,WAC/B,GAAI8C,MACAC,EAAa,EAEXC,EAAa,WACjB,GAAIC,GAAqB,KACnB5B,EAAS,SAAC6B,GAAoB,MAAAD,GAAWC,GACzCtC,EAAO,SAACuC,GAAc,MAAAF,GAASE,GAErC,QAASvC,OAAMS,UAGjB,OAAO,UAAS+B,GACd,GAAIC,GAAOD,CACNC,KACHA,EAAO,QAAUN,EACjBA,IAEF,IAAIO,GAAgBR,EAAMO,EAK1B,OAJKC,KACHA,EAAUN,IACVF,EAAMO,GAAQC,GAETA,KAIoC3E,GAAAqB,YAAWA","file":"meiosis.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar meiosis_1 = __webpack_require__(1);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = meiosis_1.meiosis;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar merge_1 = __webpack_require__(2);\n\tvar wire_1 = __webpack_require__(3);\n\tvar meiosis = function (adapters) {\n\t    var allReceivers = [];\n\t    var wire = adapters.wire || wire_1.defaultWire;\n\t    var rootWire = wire(\"meiosis\");\n\t    var merge = adapters.merge || merge_1.defaultMerge;\n\t    var rootModel = {};\n\t    var createComponent = function (config) {\n\t        if (!config || !config.view) {\n\t            throw new Error(\"At a minimum, you need to specify a view to create a component.\");\n\t        }\n\t        rootModel = merge(rootModel, config.initialModel || {});\n\t        var componentWire = wire();\n\t        var next = componentWire.emit;\n\t        var nextAction = { next: next };\n\t        var actions = config.actions ? merge(nextAction, config.actions(next)) : nextAction;\n\t        var receivers = config.receivers;\n\t        if (receivers && Array === receivers.constructor) {\n\t            Array.prototype.push.apply(allReceivers, receivers);\n\t        }\n\t        componentWire.listen(function (update) {\n\t            var updateTr = config.transform ? config.transform(rootModel, update) : update;\n\t            allReceivers.forEach(function (receiver) {\n\t                rootModel = receiver(rootModel, updateTr);\n\t                return rootModel;\n\t            });\n\t            rootWire.emit(rootModel);\n\t            if (config.chain) {\n\t                config.chain(update, actions);\n\t            }\n\t        });\n\t        return function (props) { return config.view(merge({}, props, { actions: actions })); };\n\t    };\n\t    var run = function (root) {\n\t        if (allReceivers.length === 0) {\n\t            allReceivers.push(merge);\n\t        }\n\t        var renderRoot = function (model) { adapters.render(root({ model: model })); };\n\t        rootWire.listen(renderRoot);\n\t        rootWire.emit(rootModel);\n\t        return renderRoot;\n\t    };\n\t    return { createComponent: createComponent, run: run };\n\t};\n\texports.meiosis = meiosis;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar defaultMerge = function (target) {\n\t    var sources = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        sources[_i - 1] = arguments[_i];\n\t    }\n\t    if (target === undefined || target === null) {\n\t        throw new TypeError(\"Cannot convert undefined or null to object\");\n\t    }\n\t    var output = Object(target);\n\t    for (var index = 1; index < arguments.length; index++) {\n\t        var source = arguments[index];\n\t        if (source !== undefined && source !== null) {\n\t            for (var nextKey in source) {\n\t                if (source.hasOwnProperty(nextKey)) {\n\t                    output[nextKey] = source[nextKey];\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return output;\n\t};\n\texports.defaultMerge = defaultMerge;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar defaultWire = (function () {\n\t    var wires = {};\n\t    var nextWireId = 1;\n\t    var createWire = function () {\n\t        var listener = null;\n\t        var listen = function (lstnr) { return listener = lstnr; };\n\t        var emit = function (data) { return listener(data); };\n\t        return { emit: emit, listen: listen };\n\t    };\n\t    return function (wireName) {\n\t        var name = wireName;\n\t        if (!name) {\n\t            name = \"wire_\" + nextWireId;\n\t            nextWireId++;\n\t        }\n\t        var theWire = wires[name];\n\t        if (!theWire) {\n\t            theWire = createWire();\n\t            wires[name] = theWire;\n\t        }\n\t        return theWire;\n\t    };\n\t})();\n\texports.defaultWire = defaultWire;\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** meiosis.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9e9529f28e32bde1846f\n **/","import { meiosis } from \"./meiosis\";\n\nexport default meiosis;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","import { Adapters } from \"./adapters\";\nimport { Config } from \"./config\";\nimport { Merger, defaultMerge } from \"./merge\";\nimport { Receiver } from \"./receivers\";\nimport { Emitter, Listener, WireCreator, Wire, defaultWire } from \"./wire\";\n\ninterface Component {\n  (props: any): any;\n}\n\ninterface CreateComponent {\n  (config: Config): Component;\n}\n\ninterface MeiosisInstance {\n  createComponent: CreateComponent;\n}\n\ninterface Meiosis {\n  (adapters: Adapters): MeiosisInstance;\n}\n\nconst meiosis = (adapters: Adapters) => {\n  let allReceivers: Array<Receiver> = [];\n\n  const wire: WireCreator = adapters.wire || defaultWire;\n  const rootWire = wire(\"meiosis\");\n\n  const merge: Merger = adapters.merge || defaultMerge;\n\n  let rootModel: any = {};\n\n  const createComponent = (config: Config) => {\n    if (!config || !config.view) {\n      throw new Error(\"At a minimum, you need to specify a view to create a component.\");\n    }\n    rootModel = merge(rootModel, config.initialModel || {});\n\n    const componentWire: Wire = wire();\n    const next: Emitter = componentWire.emit;\n    const nextAction = {next};\n    const actions = config.actions ? merge(nextAction, config.actions(next)) : nextAction;\n\n    const receivers: Array<Receiver> = config.receivers;\n    if (receivers && Array === receivers.constructor) {\n      Array.prototype.push.apply(allReceivers, receivers);\n    }\n\n    componentWire.listen((update: any) => {\n      const updateTr: any = config.transform ? config.transform(rootModel, update) : update;\n\n      allReceivers.forEach((receiver: Receiver) => {\n        rootModel = receiver(rootModel, updateTr);\n        return rootModel;\n      });\n\n      rootWire.emit(rootModel);\n\n      if (config.chain) {\n        config.chain(update, actions);\n      }\n    });\n\n    return (props: any) => config.view(merge({}, props, {actions}));\n  };\n\n  const run = (root: Component) => {\n    if (allReceivers.length === 0) {\n      allReceivers.push(merge);\n    }\n    const renderRoot = (model: any) => { adapters.render(root({ model })); };\n    rootWire.listen(renderRoot);\n\n    rootWire.emit(rootModel);\n\n    return renderRoot;\n  };\n\n  return { createComponent, run };\n};\n\nexport { meiosis };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meiosis.ts\n **/","interface Merger {\n  (target: any, ...sources: Array<any>): any;\n}\n\nconst defaultMerge: Merger = function(target: any, ...sources: Array<any>) {\n  if (target === undefined || target === null) {\n    throw new TypeError(\"Cannot convert undefined or null to object\");\n  }\n\n  let output = Object(target);\n  for (let index = 1; index < arguments.length; index++) {\n    const source = arguments[index];\n    if (source !== undefined && source !== null) {\n      for (let nextKey in source) {\n        if (source.hasOwnProperty(nextKey)) {\n          output[nextKey] = source[nextKey];\n        }\n      }\n    }\n  }\n  return output;\n};\n\nexport { Merger, defaultMerge };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/merge.ts\n **/","interface Listener {\n  (data: any): any;\n}\n\ninterface Emitter {\n  (data: any): any;\n}\n\ninterface Wire {\n  emit: Emitter;\n  listen(listener: Listener): any;\n}\n\ninterface WireCreator {\n  (wireName?: string): Wire;\n}\n\nconst defaultWire: WireCreator = (function() {\n  let wires = {};\n  let nextWireId = 1;\n\n  const createWire = function(): Wire {\n    let listener: Listener = null;\n    const listen = (lstnr: Listener) => listener = lstnr;\n    const emit = (data: any) => listener(data);\n\n    return { emit, listen };\n  };\n\n  return function(wireName: string) {\n    let name = wireName;\n    if (!name) {\n      name = \"wire_\" + nextWireId;\n      nextWireId++;\n    }\n    let theWire: Wire = wires[name];\n    if (!theWire) {\n      theWire = createWire();\n      wires[name] = theWire;\n    }\n    return theWire;\n  };\n})();\n\nexport { Emitter, Listener, Wire, WireCreator, defaultWire };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/wire.ts\n **/"],"sourceRoot":""}