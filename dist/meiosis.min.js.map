{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///meiosis.min.js","webpack:///webpack/bootstrap 1d853875b209dc8acb52","webpack:///./src/index.ts","webpack:///./src/meiosis.ts","webpack:///./~/flyd/lib/index.js","webpack:///./~/ramda/src/curryN.js","webpack:///./~/ramda/src/internal/_arity.js","webpack:///./~/ramda/src/internal/_curry1.js","webpack:///./~/ramda/src/internal/_isPlaceholder.js","webpack:///./~/ramda/src/internal/_curry2.js","webpack:///./~/ramda/src/internal/_curryN.js","webpack:///./~/object-path/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__export","hasOwnProperty","newInstance","propose","flyd","stream","run","params","initialModel","components","Error","getComponentFunctions","property","map","prop","filter","identity","receives","receive","model","proposal","reduce","fn","scan","states","stateFn","state","copy","nexts","nextAction","forEach","on","nestComponent","component","path","nested","subModel","objectPath","get","subState","set","componentContainer","container","getComponentIds","child","getComponentById","obj","JSON","parse","stringify","value","instance","isFunction","constructor","apply","trueFn","combine","streams","i","s","deps","depEndStreams","endStream","createDependentStream","length","undefined","push","end","depsChanged","fnArgs","concat","listeners","addListeners","updateStream","boundMap","f","ap","s2","s1","self","val","streamToString","createStream","n","arguments","updateStreamValue","hasVal","vals","queued","of","toString","depsMet","shouldUpdate","initialDepsNotMet","every","inStream","toUpdate","returnVal","flushing","flushUpdate","updateDeps","o","list","findDeps","orderNextIdx","order","shift","then","markListeners","lists","removeListener","idx","indexOf","detachDeps","StreamTransformer","curryN","initialValue","isStream","immediate","endsOn","endS","acc","ns","merge","changed","transduce","xform","source","res","prototype","v","_arity","_curry1","_curry2","_curryN","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","_isPlaceholder","f1","a","f2","b","_b","_a","received","combined","argsIdx","left","combinedIdx","result","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Object","isEmpty","isArray","type","toStr","isObject","isBoolean","getKey","key","intKey","parseInt","options","getShallowProperty","includeInheritedProps","Array","doNotReplace","split","currentPath","currentValue","slice","keys","proxy","bind","has","j","ensureExists","insert","at","arr","splice","empty","coalesce","paths","defaultValue","len","nextObj","del","currentVal","mod","create","withInheritedProps"],"mappings":"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","file":"meiosis.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar flyd = __webpack_require__(2);\n\tvar objectPath = __webpack_require__(9);\n\tvar copy = function (obj) { return JSON.parse(JSON.stringify(obj)); };\n\tvar prop = function (property) { return function (value) { return value[property]; }; };\n\tvar identity = function (value) { return value; };\n\tfunction newInstance() {\n\t    var propose = flyd.stream();\n\t    var run = function (params) {\n\t        if (!params.initialModel || !params.components) {\n\t            throw new Error(\"Please specify initialModel and components.\");\n\t        }\n\t        var getComponentFunctions = function (property, components) {\n\t            return components.map(prop(property)).filter(identity);\n\t        };\n\t        var receives = getComponentFunctions(\"receive\", params.components);\n\t        var receive = function (model, proposal) {\n\t            return receives.reduce(function (model, fn) { return fn(model, proposal); }, model);\n\t        };\n\t        var model = flyd.scan(receive, params.initialModel, propose);\n\t        var states = getComponentFunctions(\"state\", params.components);\n\t        var stateFn = function (model) {\n\t            return states.reduce(function (state, fn) { return fn(model, state); }, copy(model));\n\t        };\n\t        var state = flyd.map(stateFn, model);\n\t        var nexts = getComponentFunctions(\"nextAction\", params.components);\n\t        var nextAction = function (model, proposal) { return nexts.forEach(function (fn) { return fn(model, proposal); }); };\n\t        flyd.on(function (model) { return propose() && nextAction(model, propose()); }, model);\n\t        return {\n\t            model: model,\n\t            stateFn: stateFn,\n\t            state: state\n\t        };\n\t    };\n\t    return {\n\t        propose: propose,\n\t        run: run\n\t    };\n\t}\n\texports.newInstance = newInstance;\n\tfunction nestComponent(params) {\n\t    var component = params.component;\n\t    var path = params.path;\n\t    var nested = {\n\t        receive: component.receive && (function (model, proposal) {\n\t            var subModel = objectPath.get(model, path);\n\t            if (subModel) {\n\t                component.receive(subModel, proposal);\n\t            }\n\t            return model;\n\t        }),\n\t        nextAction: component.nextAction && (function (model, proposal) {\n\t            var subModel = objectPath.get(model, path);\n\t            if (subModel) {\n\t                component.nextAction(subModel, proposal);\n\t            }\n\t        }),\n\t        state: component.state && (function (model, state) {\n\t            var subModel = objectPath.get(model, path);\n\t            var subState = objectPath.get(state, path);\n\t            if (subModel && subState) {\n\t                objectPath.set(state, path, component.state(subModel, subState));\n\t            }\n\t            return state;\n\t        })\n\t    };\n\t    return nested;\n\t}\n\texports.nestComponent = nestComponent;\n\tfunction componentContainer(params) {\n\t    var container = {\n\t        receive: function (model, proposal) {\n\t            params.component.receive && params.component.receive(model, proposal);\n\t            params.getComponentIds(model).forEach(function (id) {\n\t                var child = params.getComponentById(id);\n\t                child.receive && child.receive(model, proposal);\n\t            });\n\t            return model;\n\t        },\n\t        state: function (model, state) {\n\t            params.component.state && params.component.state(model, state);\n\t            params.getComponentIds(model).forEach(function (id) {\n\t                var child = params.getComponentById(id);\n\t                child.state && child.state(model, state);\n\t            });\n\t            return state;\n\t        },\n\t        nextAction: function (model, proposal) {\n\t            params.component.nextAction && params.component.nextAction(model, proposal);\n\t            params.getComponentIds(model).forEach(function (id) {\n\t                var child = params.getComponentById(id);\n\t                child.nextAction && child.nextAction(model, proposal);\n\t            });\n\t        }\n\t    };\n\t    return container;\n\t}\n\texports.componentContainer = componentContainer;\n\tvar instance = newInstance();\n\tvar propose = instance.propose;\n\texports.propose = propose;\n\tvar run = instance.run;\n\texports.run = run;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar curryN = __webpack_require__(3);\n\t\n\t// Utility\n\tfunction isFunction(obj) {\n\t  return !!(obj && obj.constructor && obj.call && obj.apply);\n\t}\n\tfunction trueFn() { return true; }\n\t\n\t// Globals\n\tvar toUpdate = [];\n\tvar inStream;\n\tvar order = [];\n\tvar orderNextIdx = -1;\n\tvar flushing = false;\n\t\n\t/** @namespace */\n\tvar flyd = {}\n\t\n\t// /////////////////////////// API ///////////////////////////////// //\n\t\n\t/**\n\t * Creates a new stream\n\t *\n\t * __Signature__: `a -> Stream a`\n\t *\n\t * @name flyd.stream\n\t * @param {*} initialValue - (Optional) the initial value of the stream\n\t * @return {stream} the stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1); // Stream with initial value `1`\n\t * var s = flyd.stream(); // Stream with no initial value\n\t */\n\tflyd.stream = function(initialValue) {\n\t  var endStream = createDependentStream([], trueFn);\n\t  var s = createStream();\n\t  s.end = endStream;\n\t  s.fnArgs = [];\n\t  endStream.listeners.push(s);\n\t  if (arguments.length > 0) s(initialValue);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Create a new dependent stream\n\t *\n\t * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n\t *\n\t * @name flyd.combine\n\t * @param {Function} fn - the function used to combine the streams\n\t * @param {Array<stream>} dependencies - the streams that this one depends on\n\t * @return {stream} the dependent stream\n\t *\n\t * @example\n\t * var n1 = flyd.stream(0);\n\t * var n2 = flyd.stream(0);\n\t * var max = flyd.combine(function(n1, n2, self, changed) {\n\t *   return n1() > n2() ? n1() : n2();\n\t * }, [n1, n2]);\n\t */\n\tflyd.combine = curryN(2, combine);\n\tfunction combine(fn, streams) {\n\t  var i, s, deps, depEndStreams;\n\t  var endStream = createDependentStream([], trueFn);\n\t  deps = []; depEndStreams = [];\n\t  for (i = 0; i < streams.length; ++i) {\n\t    if (streams[i] !== undefined) {\n\t      deps.push(streams[i]);\n\t      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n\t    }\n\t  }\n\t  s = createDependentStream(deps, fn);\n\t  s.depsChanged = [];\n\t  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n\t  s.end = endStream;\n\t  endStream.listeners.push(s);\n\t  addListeners(depEndStreams, endStream);\n\t  endStream.deps = depEndStreams;\n\t  updateStream(s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n\t *\n\t * __Signature__: `* -> Boolean`\n\t *\n\t * @name flyd.isStream\n\t * @param {*} value - the value to test\n\t * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n\t *\n\t * @example\n\t * var s = flyd.stream(1);\n\t * var n = 1;\n\t * flyd.isStream(s); //=> true\n\t * flyd.isStream(n); //=> false\n\t */\n\tflyd.isStream = function(stream) {\n\t  return isFunction(stream) && 'hasVal' in stream;\n\t}\n\t\n\t/**\n\t * Invokes the body (the function to calculate the value) of a dependent stream\n\t *\n\t * By default the body of a dependent stream is only called when all the streams\n\t * upon which it depends has a value. `immediate` can circumvent this behaviour.\n\t * It immediately invokes the body of a dependent stream.\n\t *\n\t * __Signature__: `Stream a -> Stream a`\n\t *\n\t * @name flyd.immediate\n\t * @param {stream} stream - the dependent stream\n\t * @return {stream} the same stream\n\t *\n\t * @example\n\t * var s = flyd.stream();\n\t * var hasItems = flyd.immediate(flyd.combine(function(s) {\n\t *   return s() !== undefined && s().length > 0;\n\t * }, [s]);\n\t * console.log(hasItems()); // logs `false`. Had `immediate` not been\n\t *                          // used `hasItems()` would've returned `undefined`\n\t * s([1]);\n\t * console.log(hasItems()); // logs `true`.\n\t * s([]);\n\t * console.log(hasItems()); // logs `false`.\n\t */\n\tflyd.immediate = function(s) {\n\t  if (s.depsMet === false) {\n\t    s.depsMet = true;\n\t    updateStream(s);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t * Changes which `endsStream` should trigger the ending of `s`.\n\t *\n\t * __Signature__: `Stream a -> Stream b -> Stream b`\n\t *\n\t * @name flyd.endsOn\n\t * @param {stream} endStream - the stream to trigger the ending\n\t * @param {stream} stream - the stream to be ended by the endStream\n\t * @param {stream} the stream modified to be ended by endStream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var killer = flyd.stream();\n\t * // `double` ends when `n` ends or when `killer` emits any value\n\t * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n\t *   return 2 * n();\n\t * }, [n]);\n\t*/\n\tflyd.endsOn = function(endS, s) {\n\t  detachDeps(s.end);\n\t  endS.listeners.push(s.end);\n\t  s.end.deps.push(endS);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Map a stream\n\t *\n\t * Returns a new stream consisting of every value from `s` passed through\n\t * `fn`. I.e. `map` creates a new stream that listens to `s` and\n\t * applies `fn` to every new value.\n\t * __Signature__: `(a -> result) -> Stream a -> Stream result`\n\t *\n\t * @name flyd.map\n\t * @param {Function} fn - the function that produces the elements of the new stream\n\t * @param {stream} stream - the stream to map\n\t * @return {stream} a new stream with the mapped values\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n\t */\n\t// Library functions use self callback to accept (null, undefined) update triggers.\n\tflyd.map = curryN(2, function(f, s) {\n\t  return combine(function(s, self) { self(f(s.val)); }, [s]);\n\t})\n\t\n\t/**\n\t * Listen to stream events\n\t *\n\t * Similar to `map` except that the returned stream is empty. Use `on` for doing\n\t * side effects in reaction to stream changes. Use the returned stream only if you\n\t * need to manually end it.\n\t *\n\t * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n\t *\n\t * @name flyd.on\n\t * @param {Function} cb - the callback\n\t * @param {stream} stream - the stream\n\t * @return {stream} an empty stream (can be ended)\n\t */\n\tflyd.on = curryN(2, function(f, s) {\n\t  return combine(function(s) { f(s.val); }, [s]);\n\t})\n\t\n\t/**\n\t * Creates a new stream with the results of calling the function on every incoming\n\t * stream with and accumulator and the incoming value.\n\t *\n\t * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n\t *\n\t * @name flyd.scan\n\t * @param {Function} fn - the function to call\n\t * @param {*} val - the initial value of the accumulator\n\t * @param {stream} stream - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var numbers = flyd.stream();\n\t * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n\t * numbers(2)(3)(5);\n\t * sum(); // 10\n\t */\n\tflyd.scan = curryN(3, function(f, acc, s) {\n\t  var ns = combine(function(s, self) {\n\t    self(acc = f(acc, s.val));\n\t  }, [s]);\n\t  if (!ns.hasVal) ns(acc);\n\t  return ns;\n\t});\n\t\n\t/**\n\t * Creates a new stream down which all values from both `stream1` and `stream2`\n\t * will be sent.\n\t *\n\t * __Signature__: `Stream a -> Stream a -> Stream a`\n\t *\n\t * @name flyd.merge\n\t * @param {stream} source1 - one stream to be merged\n\t * @param {stream} source2 - the other stream to be merged\n\t * @return {stream} a stream with the values from both sources\n\t *\n\t * @example\n\t * var btn1Clicks = flyd.stream();\n\t * button1Elm.addEventListener(btn1Clicks);\n\t * var btn2Clicks = flyd.stream();\n\t * button2Elm.addEventListener(btn2Clicks);\n\t * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n\t */\n\tflyd.merge = curryN(2, function(s1, s2) {\n\t  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n\t    if (changed[0]) {\n\t      self(changed[0]());\n\t    } else if (s1.hasVal) {\n\t      self(s1.val);\n\t    } else if (s2.hasVal) {\n\t      self(s2.val);\n\t    }\n\t  }, [s1, s2]));\n\t  flyd.endsOn(combine(function() {\n\t    return true;\n\t  }, [s1.end, s2.end]), s);\n\t  return s;\n\t});\n\t\n\t/**\n\t * Creates a new stream resulting from applying `transducer` to `stream`.\n\t *\n\t * __Signature__: `Transducer -> Stream a -> Stream b`\n\t *\n\t * @name flyd.transduce\n\t * @param {Transducer} xform - the transducer transformation\n\t * @param {stream} source - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var t = require('transducers.js');\n\t *\n\t * var results = [];\n\t * var s1 = flyd.stream();\n\t * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n\t * var s2 = flyd.transduce(tx, s1);\n\t * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n\t * s1(1)(1)(2)(3)(3)(3)(4);\n\t * results; // => [2, 4, 6, 8]\n\t */\n\tflyd.transduce = curryN(2, function(xform, source) {\n\t  xform = xform(new StreamTransformer());\n\t  return combine(function(source, self) {\n\t    var res = xform['@@transducer/step'](undefined, source.val);\n\t    if (res && res['@@transducer/reduced'] === true) {\n\t      self.end(true);\n\t      return res['@@transducer/value'];\n\t    } else {\n\t      return res;\n\t    }\n\t  }, [source]);\n\t});\n\t\n\t/**\n\t * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n\t * modules for Flyd.\n\t *\n\t * @name flyd.curryN\n\t * @function\n\t * @param {Integer} arity - the function arity\n\t * @param {Function} fn - the function to curry\n\t * @return {Function} the curried function\n\t *\n\t * @example\n\t * function add(x, y) { return x + y; };\n\t * var a = flyd.curryN(2, add);\n\t * a(2)(4) // => 6\n\t */\n\tflyd.curryN = curryN\n\t\n\t/**\n\t * Returns a new stream identical to the original except every\n\t * value will be passed through `f`.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n\t *\n\t * @name stream.map\n\t * @param {Function} function - the function to apply\n\t * @return {stream} a new stream with the values mapped\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = numbers.map(function(n) { return n*n; });\n\t */\n\tfunction boundMap(f) { return flyd.map(f, this); }\n\t\n\t/**\n\t * Returns a new stream which is the result of applying the\n\t * functions from `this` stream to the values in `stream` parameter.\n\t *\n\t * `this` stream must be a stream of functions.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n\t *\n\t * @name stream.ap\n\t * @param {stream} stream - the values stream\n\t * @return {stream} a new stram with the functions applied to values\n\t *\n\t * @example\n\t * var add = flyd.curryN(2, function(x, y) { return x + y; });\n\t * var numbers1 = flyd.stream();\n\t * var numbers2 = flyd.stream();\n\t * var addToNumbers1 = flyd.map(add, numbers1);\n\t * var added = addToNumbers1.ap(numbers2);\n\t */\n\tfunction ap(s2) {\n\t  var s1 = this;\n\t  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n\t}\n\t\n\t/**\n\t * Get a human readable view of a stream\n\t * @name stream.toString\n\t * @return {String} the stream string representation\n\t */\n\tfunction streamToString() {\n\t  return 'stream(' + this.val + ')';\n\t}\n\t\n\t/**\n\t * @name stream.end\n\t * @memberof stream\n\t * A stream that emits `true` when the stream ends. If `true` is pushed down the\n\t * stream the parent stream ends.\n\t */\n\t\n\t/**\n\t * @name stream.of\n\t * @function\n\t * @memberof stream\n\t * Returns a new stream with `value` as its initial value. It is identical to\n\t * calling `flyd.stream` with one argument.\n\t *\n\t * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n\t *\n\t * @param {*} value - the initial value\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var m = n.of(1);\n\t */\n\t\n\t// /////////////////////////// PRIVATE ///////////////////////////////// //\n\t/**\n\t * @private\n\t * Create a stream with no dependencies and no value\n\t * @return {Function} a flyd stream\n\t */\n\tfunction createStream() {\n\t  function s(n) {\n\t    if (arguments.length === 0) return s.val\n\t    updateStreamValue(s, n)\n\t    return s\n\t  }\n\t  s.hasVal = false;\n\t  s.val = undefined;\n\t  s.vals = [];\n\t  s.listeners = [];\n\t  s.queued = false;\n\t  s.end = undefined;\n\t  s.map = boundMap;\n\t  s.ap = ap;\n\t  s.of = flyd.stream;\n\t  s.toString = streamToString;\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Create a dependent stream\n\t * @param {Array<stream>} dependencies - an array of the streams\n\t * @param {Function} fn - the function used to calculate the new stream value\n\t * from the dependencies\n\t * @return {stream} the created stream\n\t */\n\tfunction createDependentStream(deps, fn) {\n\t  var s = createStream();\n\t  s.fn = fn;\n\t  s.deps = deps;\n\t  s.depsMet = false;\n\t  s.depsChanged = deps.length > 0 ? [] : undefined;\n\t  s.shouldUpdate = false;\n\t  addListeners(deps, s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Check if all the dependencies have values\n\t * @param {stream} stream - the stream to check depencencies from\n\t * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n\t */\n\tfunction initialDepsNotMet(stream) {\n\t  stream.depsMet = stream.deps.every(function(s) {\n\t    return s.hasVal;\n\t  });\n\t  return !stream.depsMet;\n\t}\n\t\n\t/**\n\t * @private\n\t * Update a dependent stream using its dependencies in an atomic way\n\t * @param {stream} stream - the stream to update\n\t */\n\tfunction updateStream(s) {\n\t  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n\t      (s.end !== undefined && s.end.val === true)) return;\n\t  if (inStream !== undefined) {\n\t    toUpdate.push(s);\n\t    return;\n\t  }\n\t  inStream = s;\n\t  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n\t  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n\t  if (returnVal !== undefined) {\n\t    s(returnVal);\n\t  }\n\t  inStream = undefined;\n\t  if (s.depsChanged !== undefined) s.depsChanged = [];\n\t  s.shouldUpdate = false;\n\t  if (flushing === false) flushUpdate();\n\t}\n\t\n\t/**\n\t * @private\n\t * Update the dependencies of a stream\n\t * @param {stream} stream\n\t */\n\tfunction updateDeps(s) {\n\t  var i, o, list\n\t  var listeners = s.listeners;\n\t  for (i = 0; i < listeners.length; ++i) {\n\t    list = listeners[i];\n\t    if (list.end === s) {\n\t      endStream(list);\n\t    } else {\n\t      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n\t      list.shouldUpdate = true;\n\t      findDeps(list);\n\t    }\n\t  }\n\t  for (; orderNextIdx >= 0; --orderNextIdx) {\n\t    o = order[orderNextIdx];\n\t    if (o.shouldUpdate === true) updateStream(o);\n\t    o.queued = false;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add stream dependencies to the global `order` queue.\n\t * @param {stream} stream\n\t * @see updateDeps\n\t */\n\tfunction findDeps(s) {\n\t  var i\n\t  var listeners = s.listeners;\n\t  if (s.queued === false) {\n\t    s.queued = true;\n\t    for (i = 0; i < listeners.length; ++i) {\n\t      findDeps(listeners[i]);\n\t    }\n\t    order[++orderNextIdx] = s;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction flushUpdate() {\n\t  flushing = true;\n\t  while (toUpdate.length > 0) {\n\t    var s = toUpdate.shift();\n\t    if (s.vals.length > 0) s.val = s.vals.shift();\n\t    updateDeps(s);\n\t  }\n\t  flushing = false;\n\t}\n\t\n\t/**\n\t * @private\n\t * Push down a value into a stream\n\t * @param {stream} stream\n\t * @param {*} value\n\t */\n\tfunction updateStreamValue(s, n) {\n\t  if (n !== undefined && n !== null && isFunction(n.then)) {\n\t    n.then(s);\n\t    return;\n\t  }\n\t  s.val = n;\n\t  s.hasVal = true;\n\t  if (inStream === undefined) {\n\t    flushing = true;\n\t    updateDeps(s);\n\t    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n\t  } else if (inStream === s) {\n\t    markListeners(s, s.listeners);\n\t  } else {\n\t    s.vals.push(n);\n\t    toUpdate.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction markListeners(s, lists) {\n\t  var i, list;\n\t  for (i = 0; i < lists.length; ++i) {\n\t    list = lists[i];\n\t    if (list.end !== s) {\n\t      if (list.depsChanged !== undefined) {\n\t        list.depsChanged.push(s);\n\t      }\n\t      list.shouldUpdate = true;\n\t    } else {\n\t      endStream(list);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add dependencies to a stream\n\t * @param {Array<stream>} dependencies\n\t * @param {stream} stream\n\t */\n\tfunction addListeners(deps, s) {\n\t  for (var i = 0; i < deps.length; ++i) {\n\t    deps[i].listeners.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Removes an stream from a dependency array\n\t * @param {stream} stream\n\t * @param {Array<stream>} dependencies\n\t */\n\tfunction removeListener(s, listeners) {\n\t  var idx = listeners.indexOf(s);\n\t  listeners[idx] = listeners[listeners.length - 1];\n\t  listeners.length--;\n\t}\n\t\n\t/**\n\t * @private\n\t * Detach a stream from its dependencies\n\t * @param {stream} stream\n\t */\n\tfunction detachDeps(s) {\n\t  for (var i = 0; i < s.deps.length; ++i) {\n\t    removeListener(s, s.deps[i].listeners);\n\t  }\n\t  s.deps.length = 0;\n\t}\n\t\n\t/**\n\t * @private\n\t * Ends a stream\n\t */\n\tfunction endStream(s) {\n\t  if (s.deps !== undefined) detachDeps(s);\n\t  if (s.end !== undefined) detachDeps(s.end);\n\t}\n\t\n\t/**\n\t * @private\n\t * transducer stream transformer\n\t */\n\tfunction StreamTransformer() { }\n\tStreamTransformer.prototype['@@transducer/init'] = function() { };\n\tStreamTransformer.prototype['@@transducer/result'] = function() { };\n\tStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\t\n\tmodule.exports = flyd;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _curry1 = __webpack_require__(5);\n\tvar _curry2 = __webpack_require__(7);\n\tvar _curryN = __webpack_require__(8);\n\t\n\t\n\t/**\n\t * Returns a curried equivalent of the provided function, with the specified\n\t * arity. The curried function has two unusual capabilities. First, its\n\t * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1)(2)(3)`\n\t *   - `g(1)(2, 3)`\n\t *   - `g(1, 2)(3)`\n\t *   - `g(1, 2, 3)`\n\t *\n\t * Secondly, the special placeholder value `R.__` may be used to specify\n\t * \"gaps\", allowing partial application of any combination of arguments,\n\t * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1, 2, 3)`\n\t *   - `g(_, 2, 3)(1)`\n\t *   - `g(_, _, 3)(1)(2)`\n\t *   - `g(_, _, 3)(1, 2)`\n\t *   - `g(_, 2)(1)(3)`\n\t *   - `g(_, 2)(1, 3)`\n\t *   - `g(_, 2)(_, 3)(1)`\n\t *\n\t * @func\n\t * @memberOf R\n\t * @since v0.5.0\n\t * @category Function\n\t * @sig Number -> (* -> a) -> (* -> a)\n\t * @param {Number} length The arity for the returned function.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} A new, curried function.\n\t * @see R.curry\n\t * @example\n\t *\n\t *      var sumArgs = (...args) => R.sum(args);\n\t *\n\t *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n\t *      var f = curriedAddFourNumbers(1, 2);\n\t *      var g = f(3);\n\t *      g(4); //=> 10\n\t */\n\tmodule.exports = _curry2(function curryN(length, fn) {\n\t  if (length === 1) {\n\t    return _curry1(fn);\n\t  }\n\t  return _arity(length, _curryN(length, [], fn));\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _arity(n, fn) {\n\t  /* eslint-disable no-unused-vars */\n\t  switch (n) {\n\t    case 0: return function() { return fn.apply(this, arguments); };\n\t    case 1: return function(a0) { return fn.apply(this, arguments); };\n\t    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n\t    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n\t    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n\t    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n\t    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n\t    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n\t    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n\t    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n\t    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n\t    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n\t  }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal one-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry1(fn) {\n\t  return function f1(a) {\n\t    if (arguments.length === 0 || _isPlaceholder(a)) {\n\t      return f1;\n\t    } else {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _isPlaceholder(a) {\n\t  return a != null &&\n\t         typeof a === 'object' &&\n\t         a['@@functional/placeholder'] === true;\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _curry1 = __webpack_require__(5);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal two-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry2(fn) {\n\t  return function f2(a, b) {\n\t    switch (arguments.length) {\n\t      case 0:\n\t        return f2;\n\t      case 1:\n\t        return _isPlaceholder(a) ? f2\n\t             : _curry1(function(_b) { return fn(a, _b); });\n\t      default:\n\t        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n\t             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n\t             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n\t             : fn(a, b);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Internal curryN function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Number} length The arity of the curried function.\n\t * @param {Array} received An array of arguments received thus far.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curryN(length, received, fn) {\n\t  return function() {\n\t    var combined = [];\n\t    var argsIdx = 0;\n\t    var left = length;\n\t    var combinedIdx = 0;\n\t    while (combinedIdx < received.length || argsIdx < arguments.length) {\n\t      var result;\n\t      if (combinedIdx < received.length &&\n\t          (!_isPlaceholder(received[combinedIdx]) ||\n\t           argsIdx >= arguments.length)) {\n\t        result = received[combinedIdx];\n\t      } else {\n\t        result = arguments[argsIdx];\n\t        argsIdx += 1;\n\t      }\n\t      combined[combinedIdx] = result;\n\t      if (!_isPlaceholder(result)) {\n\t        left -= 1;\n\t      }\n\t      combinedIdx += 1;\n\t    }\n\t    return left <= 0 ? fn.apply(this, combined)\n\t                     : _arity(left, _curryN(length, combined, fn));\n\t  };\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n\t  'use strict';\n\t\n\t  /*istanbul ignore next:cant test*/\n\t  if (typeof module === 'object' && typeof module.exports === 'object') {\n\t    module.exports = factory();\n\t  } else if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else {\n\t    // Browser globals\n\t    root.objectPath = factory();\n\t  }\n\t})(this, function(){\n\t  'use strict';\n\t\n\t  var toStr = Object.prototype.toString;\n\t  function hasOwnProperty(obj, prop) {\n\t    if(obj == null) {\n\t      return false\n\t    }\n\t    //to handle objects with null prototypes (too edge case?)\n\t    return Object.prototype.hasOwnProperty.call(obj, prop)\n\t  }\n\t\n\t  function isEmpty(value){\n\t    if (!value) {\n\t      return true;\n\t    }\n\t    if (isArray(value) && value.length === 0) {\n\t        return true;\n\t    } else if (typeof value !== 'string') {\n\t        for (var i in value) {\n\t            if (hasOwnProperty(value, i)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function toString(type){\n\t    return toStr.call(type);\n\t  }\n\t\n\t  function isObject(obj){\n\t    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n\t  }\n\t\n\t  var isArray = Array.isArray || function(obj){\n\t    /*istanbul ignore next:cant test*/\n\t    return toStr.call(obj) === '[object Array]';\n\t  }\n\t\n\t  function isBoolean(obj){\n\t    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n\t  }\n\t\n\t  function getKey(key){\n\t    var intKey = parseInt(key);\n\t    if (intKey.toString() === key) {\n\t      return intKey;\n\t    }\n\t    return key;\n\t  }\n\t\n\t  function factory(options) {\n\t    options = options || {}\n\t\n\t    var objectPath = function(obj) {\n\t      return Object.keys(objectPath).reduce(function(proxy, prop) {\n\t        if(prop === 'create') {\n\t          return proxy;\n\t        }\n\t\n\t        /*istanbul ignore else*/\n\t        if (typeof objectPath[prop] === 'function') {\n\t          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n\t        }\n\t\n\t        return proxy;\n\t      }, {});\n\t    };\n\t\n\t    function getShallowProperty(obj, prop) {\n\t      if (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)) {\n\t        return obj[prop];\n\t      }\n\t    }\n\t\n\t    function set(obj, path, value, doNotReplace){\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t      if (!path || path.length === 0) {\n\t        return obj;\n\t      }\n\t      if (typeof path === 'string') {\n\t        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n\t      }\n\t      var currentPath = path[0];\n\t      var currentValue = getShallowProperty(obj, currentPath);\n\t      if (path.length === 1) {\n\t        if (currentValue === void 0 || !doNotReplace) {\n\t          obj[currentPath] = value;\n\t        }\n\t        return currentValue;\n\t      }\n\t\n\t      if (currentValue === void 0) {\n\t        //check if we assume an array\n\t        if(typeof path[1] === 'number') {\n\t          obj[currentPath] = [];\n\t        } else {\n\t          obj[currentPath] = {};\n\t        }\n\t      }\n\t\n\t      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n\t    }\n\t\n\t    objectPath.has = function (obj, path) {\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      } else if (typeof path === 'string') {\n\t        path = path.split('.');\n\t      }\n\t\n\t      if (!path || path.length === 0) {\n\t        return !!obj;\n\t      }\n\t\n\t      for (var i = 0; i < path.length; i++) {\n\t        var j = getKey(path[i]);\n\t\n\t        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n\t          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n\t          obj = obj[j];\n\t        } else {\n\t          return false;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    objectPath.ensureExists = function (obj, path, value){\n\t      return set(obj, path, value, true);\n\t    };\n\t\n\t    objectPath.set = function (obj, path, value, doNotReplace){\n\t      return set(obj, path, value, doNotReplace);\n\t    };\n\t\n\t    objectPath.insert = function (obj, path, value, at){\n\t      var arr = objectPath.get(obj, path);\n\t      at = ~~at;\n\t      if (!isArray(arr)) {\n\t        arr = [];\n\t        objectPath.set(obj, path, arr);\n\t      }\n\t      arr.splice(at, 0, value);\n\t    };\n\t\n\t    objectPath.empty = function(obj, path) {\n\t      if (isEmpty(path)) {\n\t        return void 0;\n\t      }\n\t      if (obj == null) {\n\t        return void 0;\n\t      }\n\t\n\t      var value, i;\n\t      if (!(value = objectPath.get(obj, path))) {\n\t        return void 0;\n\t      }\n\t\n\t      if (typeof value === 'string') {\n\t        return objectPath.set(obj, path, '');\n\t      } else if (isBoolean(value)) {\n\t        return objectPath.set(obj, path, false);\n\t      } else if (typeof value === 'number') {\n\t        return objectPath.set(obj, path, 0);\n\t      } else if (isArray(value)) {\n\t        value.length = 0;\n\t      } else if (isObject(value)) {\n\t        for (i in value) {\n\t          if (hasOwnProperty(value, i)) {\n\t            delete value[i];\n\t          }\n\t        }\n\t      } else {\n\t        return objectPath.set(obj, path, null);\n\t      }\n\t    };\n\t\n\t    objectPath.push = function (obj, path /*, values */){\n\t      var arr = objectPath.get(obj, path);\n\t      if (!isArray(arr)) {\n\t        arr = [];\n\t        objectPath.set(obj, path, arr);\n\t      }\n\t\n\t      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n\t    };\n\t\n\t    objectPath.coalesce = function (obj, paths, defaultValue) {\n\t      var value;\n\t\n\t      for (var i = 0, len = paths.length; i < len; i++) {\n\t        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n\t          return value;\n\t        }\n\t      }\n\t\n\t      return defaultValue;\n\t    };\n\t\n\t    objectPath.get = function (obj, path, defaultValue){\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t      if (!path || path.length === 0) {\n\t        return obj;\n\t      }\n\t      if (obj == null) {\n\t        return defaultValue;\n\t      }\n\t      if (typeof path === 'string') {\n\t        return objectPath.get(obj, path.split('.'), defaultValue);\n\t      }\n\t\n\t      var currentPath = getKey(path[0]);\n\t      var nextObj = getShallowProperty(obj, currentPath)\n\t      if (nextObj === void 0) {\n\t        return defaultValue;\n\t      }\n\t\n\t      if (path.length === 1) {\n\t        return nextObj;\n\t      }\n\t\n\t      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n\t    };\n\t\n\t    objectPath.del = function del(obj, path) {\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t\n\t      if (obj == null) {\n\t        return obj;\n\t      }\n\t\n\t      if (isEmpty(path)) {\n\t        return obj;\n\t      }\n\t      if(typeof path === 'string') {\n\t        return objectPath.del(obj, path.split('.'));\n\t      }\n\t\n\t      var currentPath = getKey(path[0]);\n\t      var currentVal = getShallowProperty(obj, currentPath);\n\t      if(currentVal == null) {\n\t        return currentVal;\n\t      }\n\t\n\t      if(path.length === 1) {\n\t        if (isArray(obj)) {\n\t          obj.splice(currentPath, 1);\n\t        } else {\n\t          delete obj[currentPath];\n\t        }\n\t      } else {\n\t        if (obj[currentPath] !== void 0) {\n\t          return objectPath.del(obj[currentPath], path.slice(1));\n\t        }\n\t      }\n\t\n\t      return obj;\n\t    }\n\t\n\t    return objectPath;\n\t  }\n\t\n\t  var mod = factory();\n\t  mod.create = factory;\n\t  mod.withInheritedProps = factory({includeInheritedProps: true})\n\t  return mod;\n\t});\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// meiosis.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1d853875b209dc8acb52","export * from \"./meiosis\";\nexport * from \"./component\";\nexport * from \"./nextAction\";\nexport * from \"./receive\";\nexport * from \"./state\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as flyd from \"flyd\";\nimport * as objectPath from \"object-path\";\nimport { Component } from \"./component\";\nimport { Receive } from \"./receive\";\nimport { ComponentState, State } from \"./state\";\nimport { NextAction } from \"./nextAction\";\n\ntype Stream<T> = Flyd.Stream<T>;\n\nexport interface RunParameters<M, P, S> {\n  initialModel: M;\n  components: Array<Component<M, P, S>>;\n}\n\nexport interface MeiosisRun<M, P, S> {\n  (params: RunParameters<M, P, S>): MeiosisApp<M, P, S>;\n}\n\nexport interface MeiosisInstance<M, P, S> {\n  propose: Flyd.Stream<P>;\n  run: MeiosisRun<M, P, S>;\n}\n\nexport interface MeiosisApp<M, P, S> {\n  model: Flyd.Stream<M>;\n  stateFn: State<M, S>;\n  state: Flyd.Stream<S>;\n}\n\nconst copy = (obj: any): any => JSON.parse(JSON.stringify(obj));\nconst prop = (property: string) => (value: any) => value[property];\nconst identity = <T>(value: T) => value;\n\nfunction newInstance<M, P, S>(): MeiosisInstance<M, P, S> {\n  const propose: Stream<P> = flyd.stream<P>();\n\n  const run = (params: RunParameters<M, P, S>): MeiosisApp<M, P, S> => {\n    if (!params.initialModel || !params.components) {\n      throw new Error(\"Please specify initialModel and components.\");\n    }\n    const getComponentFunctions = <M, P, S>(property: string, components: Array<Component<M, P, S>>) =>\n      components.map(prop(property)).filter(identity);\n\n    const receives: Array<Receive<M, P>> = getComponentFunctions(\"receive\", params.components);\n    const receive: Receive<M, P> = (model: M, proposal: P) =>\n      receives.reduce((model, fn) => fn(model, proposal), model);\n\n    const model: Stream<M> = flyd.scan<P, M>(receive, params.initialModel, propose);\n\n    const states: Array<ComponentState<M, S>> = getComponentFunctions(\"state\", params.components);\n    const stateFn: State<M, S> = (model: M) =>\n      states.reduce((state, fn) => fn(model, state), copy(model));\n\n    const state: Stream<S> = flyd.map<M, S>(stateFn, model);\n\n    const nexts: Array<NextAction<M, P>> = getComponentFunctions(\"nextAction\", params.components);\n    const nextAction: NextAction<M, P> = (model: M, proposal: P) => nexts.forEach(fn => fn(model, proposal));\n\n    flyd.on(model => propose() && nextAction(model, propose()), model);\n\n    return {\n      model,\n      stateFn,\n      state\n    };\n  };\n\n  return {\n    propose,\n    run\n  };\n}\n\nexport interface NestComponent<N, P, T> {\n  component: Component<N, P, T>;\n  path: string;\n}\n\nfunction nestComponent<M, N, P, S, T>(params: NestComponent<N, P, T>): Component<M, P, S> {\n  const component: Component<N, P, T> = params.component;\n  const path: string = params.path;\n\n  const nested: Component<M, P, S> = {\n    receive: component.receive && ((model: M, proposal: P) => {\n      const subModel: N = objectPath.get<M, N>(model, path);\n\n      if (subModel) {\n        component.receive(subModel, proposal);\n      }\n      return model;\n    }),\n    nextAction: component.nextAction && ((model: M, proposal: P) => {\n      const subModel: N = objectPath.get<M, N>(model, path);\n\n      if (subModel) {\n        component.nextAction(subModel, proposal);\n      }\n    }),\n    state: component.state && ((model: M, state: S) => {\n      const subModel: N = objectPath.get<M, N>(model, path);\n      const subState: T = objectPath.get<S, T>(state, path);\n\n      if (subModel && subState) {\n        objectPath.set<S, T>(state, path, component.state(subModel, subState));\n      }\n      return state;\n    })\n  };\n  return nested;\n}\n\nexport interface ComponentContainer<M, P, S> {\n  component: Component<M, P, S>;\n  getComponentIds: (model: M) => Array<string>;\n  getComponentById: (id: string) => Component<M, P, S>;\n}\n\nfunction componentContainer<M, P, S>(params: ComponentContainer<M, P, S>): Component<M, P, S> {\n  const container: Component<M, P, S> = {\n    receive: (model: M, proposal: P) => {\n      params.component.receive && params.component.receive(model, proposal);\n      params.getComponentIds(model).forEach(id => {\n        const child: Component<M, P, S> = params.getComponentById(id);\n        child.receive && child.receive(model, proposal);\n      });\n      return model;\n    },\n    state: (model: M, state: S) => {\n      params.component.state && params.component.state(model, state);\n      params.getComponentIds(model).forEach(id => {\n        const child: Component<M, P, S> = params.getComponentById(id);\n        child.state && child.state(model, state);\n      });\n      return state;\n    },\n    nextAction: (model: M, proposal: P) => {\n      params.component.nextAction && params.component.nextAction(model, proposal);\n      params.getComponentIds(model).forEach(id => {\n        const child: Component<M, P, S> = params.getComponentById(id);\n        child.nextAction && child.nextAction(model, proposal);\n      });\n    }\n  };\n  return container;\n}\n\nconst instance = newInstance<any, any, any>();\nconst propose = instance.propose;\nconst run = instance.run;\n\nexport {\n  newInstance,\n  propose,\n  run,\n  nestComponent,\n  componentContainer\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/meiosis.ts","'use strict';\n\nvar curryN = require('ramda/src/curryN');\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stram with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/flyd/lib/index.js\n// module id = 2\n// module chunks = 0","var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _curry2 = require('./internal/_curry2');\nvar _curryN = require('./internal/_curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/curryN.js\n// module id = 3\n// module chunks = 0","module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_arity.js\n// module id = 4\n// module chunks = 0","var _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry1.js\n// module id = 5\n// module chunks = 0","module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_isPlaceholder.js\n// module id = 6\n// module chunks = 0","var _curry1 = require('./_curry1');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry2.js\n// module id = 7\n// module chunks = 0","var _arity = require('./_arity');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curryN.js\n// module id = 8\n// module chunks = 0","(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    function getShallowProperty(obj, prop) {\n      if (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasOwnProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      var currentVal = getShallowProperty(obj, currentPath);\n      if(currentVal == null) {\n        return currentVal;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        if (obj[currentPath] !== void 0) {\n          return objectPath.del(obj[currentPath], path.slice(1));\n        }\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-path/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}