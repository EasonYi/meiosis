{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///meiosis.min.js","webpack:///webpack/bootstrap bf8ce819239bd3bcfaa8","webpack:///./src/index.ts","webpack:///./src/meiosis.ts","webpack:///./~/flyd/lib/index.js","webpack:///./~/ramda/src/curryN.js","webpack:///./~/ramda/src/internal/_arity.js","webpack:///./~/ramda/src/internal/_curry1.js","webpack:///./~/ramda/src/internal/_isPlaceholder.js","webpack:///./~/ramda/src/internal/_curry2.js","webpack:///./~/ramda/src/internal/_curryN.js","webpack:///./~/object-path/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__export","hasOwnProperty","newInstance","propose","flyd","stream","run","params","initialModel","components","Error","getComponentFunctions","property","map","prop","filter","identity","addAllComponents","list","children","forEach","child","push","initialModels","reduce","model","fn","receives","receive","proposal","scan","states","stateFn","state","copy","nexts","nextAction","on","nestComponent","component","path","nested","subModel","objectPath","get","subState","set","componentContainer","container","getComponents","obj","JSON","parse","stringify","value","instance","combine","merge","isFunction","constructor","apply","trueFn","streams","i","s","deps","depEndStreams","endStream","createDependentStream","length","undefined","end","depsChanged","fnArgs","concat","listeners","addListeners","updateStream","boundMap","f","ap","s2","s1","self","val","streamToString","createStream","n","arguments","updateStreamValue","hasVal","vals","queued","of","toString","depsMet","shouldUpdate","initialDepsNotMet","every","inStream","toUpdate","returnVal","flushing","flushUpdate","updateDeps","o","findDeps","orderNextIdx","order","shift","then","markListeners","lists","removeListener","idx","indexOf","detachDeps","StreamTransformer","curryN","initialValue","isStream","immediate","endsOn","endS","acc","ns","changed","transduce","xform","source","res","prototype","v","_arity","_curry1","_curry2","_curryN","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","_isPlaceholder","f1","a","f2","b","_b","_a","received","combined","argsIdx","left","combinedIdx","result","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Object","isEmpty","isArray","type","toStr","isObject","isBoolean","getKey","key","intKey","parseInt","options","getShallowProperty","includeInheritedProps","Array","doNotReplace","split","currentPath","currentValue","slice","keys","proxy","bind","has","j","ensureExists","insert","at","arr","splice","empty","coalesce","paths","defaultValue","len","nextObj","del","currentVal","mod","create","withInheritedProps"],"mappings":"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","file":"meiosis.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"meiosis\"] = factory();\n\telse\n\t\troot[\"meiosis\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar flyd = __webpack_require__(2);\n\tvar objectPath = __webpack_require__(9);\n\tvar copy = function (obj) { return JSON.parse(JSON.stringify(obj)); };\n\tvar prop = function (property) { return function (value) { return value[property]; }; };\n\tvar identity = function (value) { return value; };\n\tfunction newInstance() {\n\t    var propose = flyd.stream();\n\t    var run = function (params) {\n\t        if (!params.initialModel || !params.components) {\n\t            throw new Error(\"Please specify initialModel and components.\");\n\t        }\n\t        var getComponentFunctions = function (property, components) {\n\t            return components.map(prop(property)).filter(identity);\n\t        };\n\t        var addAllComponents = function (components, list) {\n\t            var children = list || [];\n\t            children.forEach(function (child) {\n\t                components.push(child);\n\t                addAllComponents(components, child.components);\n\t            });\n\t        };\n\t        var components = [];\n\t        addAllComponents(components, params.components);\n\t        var initialModels = getComponentFunctions(\"initialModel\", components);\n\t        var initialModel = initialModels.reduce(function (model, fn) { return fn(model); }, params.initialModel);\n\t        var receives = getComponentFunctions(\"receive\", components);\n\t        var receive = function (model, proposal) {\n\t            return receives.reduce(function (model, fn) { return fn(model, proposal); }, model);\n\t        };\n\t        var model = flyd.scan(receive, initialModel, propose);\n\t        var states = getComponentFunctions(\"state\", components);\n\t        var stateFn = function (model) {\n\t            return states.reduce(function (state, fn) { return fn(model, state); }, copy(model));\n\t        };\n\t        var state = flyd.map(stateFn, model);\n\t        var nexts = getComponentFunctions(\"nextAction\", components);\n\t        var nextAction = function (model, proposal) { return nexts.forEach(function (fn) { return fn(model, proposal); }); };\n\t        flyd.on(function (model) { return propose() && nextAction(model, propose()); }, model);\n\t        return {\n\t            model: model,\n\t            stateFn: stateFn,\n\t            state: state\n\t        };\n\t    };\n\t    return {\n\t        propose: propose,\n\t        run: run\n\t    };\n\t}\n\texports.newInstance = newInstance;\n\tfunction nestComponent(params) {\n\t    var component = params.component;\n\t    var path = params.path;\n\t    var nested = {\n\t        initialModel: component.initialModel,\n\t        components: component.components,\n\t        receive: component.receive && (function (model, proposal) {\n\t            var subModel = objectPath.get(model, path);\n\t            if (subModel) {\n\t                component.receive(subModel, proposal);\n\t            }\n\t            return model;\n\t        }),\n\t        nextAction: component.nextAction && (function (model, proposal) {\n\t            var subModel = objectPath.get(model, path);\n\t            if (subModel) {\n\t                component.nextAction(subModel, proposal);\n\t            }\n\t        }),\n\t        state: component.state && (function (model, state) {\n\t            var subModel = objectPath.get(model, path);\n\t            var subState = objectPath.get(state, path);\n\t            if (subModel && subState) {\n\t                objectPath.set(state, path, component.state(subModel, subState));\n\t            }\n\t            return state;\n\t        })\n\t    };\n\t    return nested;\n\t}\n\texports.nestComponent = nestComponent;\n\tfunction componentContainer(params) {\n\t    var container = {\n\t        initialModel: params.component.initialModel,\n\t        components: params.component.components,\n\t        receive: function (model, proposal) {\n\t            params.component.receive && params.component.receive(model, proposal);\n\t            params.getComponents(model).forEach(function (child) { return child.receive && child.receive(model, proposal); });\n\t            return model;\n\t        },\n\t        state: function (model, state) {\n\t            params.component.state && params.component.state(model, state);\n\t            params.getComponents(model).forEach(function (child) { return child.state && child.state(model, state); });\n\t            return state;\n\t        },\n\t        nextAction: function (model, proposal) {\n\t            params.component.nextAction && params.component.nextAction(model, proposal);\n\t            params.getComponents(model).forEach(function (child) { return child.nextAction && child.nextAction(model, proposal); });\n\t        }\n\t    };\n\t    return container;\n\t}\n\texports.componentContainer = componentContainer;\n\tvar instance = newInstance();\n\tvar propose = instance.propose;\n\texports.propose = propose;\n\tvar run = instance.run;\n\texports.run = run;\n\texports.combine = flyd.combine, exports.map = flyd.map, exports.merge = flyd.merge, exports.on = flyd.on, exports.scan = flyd.scan;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar curryN = __webpack_require__(3);\n\t\n\t// Utility\n\tfunction isFunction(obj) {\n\t  return !!(obj && obj.constructor && obj.call && obj.apply);\n\t}\n\tfunction trueFn() { return true; }\n\t\n\t// Globals\n\tvar toUpdate = [];\n\tvar inStream;\n\tvar order = [];\n\tvar orderNextIdx = -1;\n\tvar flushing = false;\n\t\n\t/** @namespace */\n\tvar flyd = {}\n\t\n\t// /////////////////////////// API ///////////////////////////////// //\n\t\n\t/**\n\t * Creates a new stream\n\t *\n\t * __Signature__: `a -> Stream a`\n\t *\n\t * @name flyd.stream\n\t * @param {*} initialValue - (Optional) the initial value of the stream\n\t * @return {stream} the stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1); // Stream with initial value `1`\n\t * var s = flyd.stream(); // Stream with no initial value\n\t */\n\tflyd.stream = function(initialValue) {\n\t  var endStream = createDependentStream([], trueFn);\n\t  var s = createStream();\n\t  s.end = endStream;\n\t  s.fnArgs = [];\n\t  endStream.listeners.push(s);\n\t  if (arguments.length > 0) s(initialValue);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Create a new dependent stream\n\t *\n\t * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n\t *\n\t * @name flyd.combine\n\t * @param {Function} fn - the function used to combine the streams\n\t * @param {Array<stream>} dependencies - the streams that this one depends on\n\t * @return {stream} the dependent stream\n\t *\n\t * @example\n\t * var n1 = flyd.stream(0);\n\t * var n2 = flyd.stream(0);\n\t * var max = flyd.combine(function(n1, n2, self, changed) {\n\t *   return n1() > n2() ? n1() : n2();\n\t * }, [n1, n2]);\n\t */\n\tflyd.combine = curryN(2, combine);\n\tfunction combine(fn, streams) {\n\t  var i, s, deps, depEndStreams;\n\t  var endStream = createDependentStream([], trueFn);\n\t  deps = []; depEndStreams = [];\n\t  for (i = 0; i < streams.length; ++i) {\n\t    if (streams[i] !== undefined) {\n\t      deps.push(streams[i]);\n\t      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n\t    }\n\t  }\n\t  s = createDependentStream(deps, fn);\n\t  s.depsChanged = [];\n\t  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n\t  s.end = endStream;\n\t  endStream.listeners.push(s);\n\t  addListeners(depEndStreams, endStream);\n\t  endStream.deps = depEndStreams;\n\t  updateStream(s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n\t *\n\t * __Signature__: `* -> Boolean`\n\t *\n\t * @name flyd.isStream\n\t * @param {*} value - the value to test\n\t * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n\t *\n\t * @example\n\t * var s = flyd.stream(1);\n\t * var n = 1;\n\t * flyd.isStream(s); //=> true\n\t * flyd.isStream(n); //=> false\n\t */\n\tflyd.isStream = function(stream) {\n\t  return isFunction(stream) && 'hasVal' in stream;\n\t}\n\t\n\t/**\n\t * Invokes the body (the function to calculate the value) of a dependent stream\n\t *\n\t * By default the body of a dependent stream is only called when all the streams\n\t * upon which it depends has a value. `immediate` can circumvent this behaviour.\n\t * It immediately invokes the body of a dependent stream.\n\t *\n\t * __Signature__: `Stream a -> Stream a`\n\t *\n\t * @name flyd.immediate\n\t * @param {stream} stream - the dependent stream\n\t * @return {stream} the same stream\n\t *\n\t * @example\n\t * var s = flyd.stream();\n\t * var hasItems = flyd.immediate(flyd.combine(function(s) {\n\t *   return s() !== undefined && s().length > 0;\n\t * }, [s]);\n\t * console.log(hasItems()); // logs `false`. Had `immediate` not been\n\t *                          // used `hasItems()` would've returned `undefined`\n\t * s([1]);\n\t * console.log(hasItems()); // logs `true`.\n\t * s([]);\n\t * console.log(hasItems()); // logs `false`.\n\t */\n\tflyd.immediate = function(s) {\n\t  if (s.depsMet === false) {\n\t    s.depsMet = true;\n\t    updateStream(s);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t * Changes which `endsStream` should trigger the ending of `s`.\n\t *\n\t * __Signature__: `Stream a -> Stream b -> Stream b`\n\t *\n\t * @name flyd.endsOn\n\t * @param {stream} endStream - the stream to trigger the ending\n\t * @param {stream} stream - the stream to be ended by the endStream\n\t * @param {stream} the stream modified to be ended by endStream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var killer = flyd.stream();\n\t * // `double` ends when `n` ends or when `killer` emits any value\n\t * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n\t *   return 2 * n();\n\t * }, [n]);\n\t*/\n\tflyd.endsOn = function(endS, s) {\n\t  detachDeps(s.end);\n\t  endS.listeners.push(s.end);\n\t  s.end.deps.push(endS);\n\t  return s;\n\t}\n\t\n\t/**\n\t * Map a stream\n\t *\n\t * Returns a new stream consisting of every value from `s` passed through\n\t * `fn`. I.e. `map` creates a new stream that listens to `s` and\n\t * applies `fn` to every new value.\n\t * __Signature__: `(a -> result) -> Stream a -> Stream result`\n\t *\n\t * @name flyd.map\n\t * @param {Function} fn - the function that produces the elements of the new stream\n\t * @param {stream} stream - the stream to map\n\t * @return {stream} a new stream with the mapped values\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n\t */\n\t// Library functions use self callback to accept (null, undefined) update triggers.\n\tflyd.map = curryN(2, function(f, s) {\n\t  return combine(function(s, self) { self(f(s.val)); }, [s]);\n\t})\n\t\n\t/**\n\t * Listen to stream events\n\t *\n\t * Similar to `map` except that the returned stream is empty. Use `on` for doing\n\t * side effects in reaction to stream changes. Use the returned stream only if you\n\t * need to manually end it.\n\t *\n\t * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n\t *\n\t * @name flyd.on\n\t * @param {Function} cb - the callback\n\t * @param {stream} stream - the stream\n\t * @return {stream} an empty stream (can be ended)\n\t */\n\tflyd.on = curryN(2, function(f, s) {\n\t  return combine(function(s) { f(s.val); }, [s]);\n\t})\n\t\n\t/**\n\t * Creates a new stream with the results of calling the function on every incoming\n\t * stream with and accumulator and the incoming value.\n\t *\n\t * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n\t *\n\t * @name flyd.scan\n\t * @param {Function} fn - the function to call\n\t * @param {*} val - the initial value of the accumulator\n\t * @param {stream} stream - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var numbers = flyd.stream();\n\t * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n\t * numbers(2)(3)(5);\n\t * sum(); // 10\n\t */\n\tflyd.scan = curryN(3, function(f, acc, s) {\n\t  var ns = combine(function(s, self) {\n\t    self(acc = f(acc, s.val));\n\t  }, [s]);\n\t  if (!ns.hasVal) ns(acc);\n\t  return ns;\n\t});\n\t\n\t/**\n\t * Creates a new stream down which all values from both `stream1` and `stream2`\n\t * will be sent.\n\t *\n\t * __Signature__: `Stream a -> Stream a -> Stream a`\n\t *\n\t * @name flyd.merge\n\t * @param {stream} source1 - one stream to be merged\n\t * @param {stream} source2 - the other stream to be merged\n\t * @return {stream} a stream with the values from both sources\n\t *\n\t * @example\n\t * var btn1Clicks = flyd.stream();\n\t * button1Elm.addEventListener(btn1Clicks);\n\t * var btn2Clicks = flyd.stream();\n\t * button2Elm.addEventListener(btn2Clicks);\n\t * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n\t */\n\tflyd.merge = curryN(2, function(s1, s2) {\n\t  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n\t    if (changed[0]) {\n\t      self(changed[0]());\n\t    } else if (s1.hasVal) {\n\t      self(s1.val);\n\t    } else if (s2.hasVal) {\n\t      self(s2.val);\n\t    }\n\t  }, [s1, s2]));\n\t  flyd.endsOn(combine(function() {\n\t    return true;\n\t  }, [s1.end, s2.end]), s);\n\t  return s;\n\t});\n\t\n\t/**\n\t * Creates a new stream resulting from applying `transducer` to `stream`.\n\t *\n\t * __Signature__: `Transducer -> Stream a -> Stream b`\n\t *\n\t * @name flyd.transduce\n\t * @param {Transducer} xform - the transducer transformation\n\t * @param {stream} source - the stream source\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var t = require('transducers.js');\n\t *\n\t * var results = [];\n\t * var s1 = flyd.stream();\n\t * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n\t * var s2 = flyd.transduce(tx, s1);\n\t * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n\t * s1(1)(1)(2)(3)(3)(3)(4);\n\t * results; // => [2, 4, 6, 8]\n\t */\n\tflyd.transduce = curryN(2, function(xform, source) {\n\t  xform = xform(new StreamTransformer());\n\t  return combine(function(source, self) {\n\t    var res = xform['@@transducer/step'](undefined, source.val);\n\t    if (res && res['@@transducer/reduced'] === true) {\n\t      self.end(true);\n\t      return res['@@transducer/value'];\n\t    } else {\n\t      return res;\n\t    }\n\t  }, [source]);\n\t});\n\t\n\t/**\n\t * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n\t * modules for Flyd.\n\t *\n\t * @name flyd.curryN\n\t * @function\n\t * @param {Integer} arity - the function arity\n\t * @param {Function} fn - the function to curry\n\t * @return {Function} the curried function\n\t *\n\t * @example\n\t * function add(x, y) { return x + y; };\n\t * var a = flyd.curryN(2, add);\n\t * a(2)(4) // => 6\n\t */\n\tflyd.curryN = curryN\n\t\n\t/**\n\t * Returns a new stream identical to the original except every\n\t * value will be passed through `f`.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n\t *\n\t * @name stream.map\n\t * @param {Function} function - the function to apply\n\t * @return {stream} a new stream with the values mapped\n\t *\n\t * @example\n\t * var numbers = flyd.stream(0);\n\t * var squaredNumbers = numbers.map(function(n) { return n*n; });\n\t */\n\tfunction boundMap(f) { return flyd.map(f, this); }\n\t\n\t/**\n\t * Returns a new stream which is the result of applying the\n\t * functions from `this` stream to the values in `stream` parameter.\n\t *\n\t * `this` stream must be a stream of functions.\n\t *\n\t * _Note:_ This function is included in order to support the fantasy land\n\t * specification.\n\t *\n\t * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n\t *\n\t * @name stream.ap\n\t * @param {stream} stream - the values stream\n\t * @return {stream} a new stram with the functions applied to values\n\t *\n\t * @example\n\t * var add = flyd.curryN(2, function(x, y) { return x + y; });\n\t * var numbers1 = flyd.stream();\n\t * var numbers2 = flyd.stream();\n\t * var addToNumbers1 = flyd.map(add, numbers1);\n\t * var added = addToNumbers1.ap(numbers2);\n\t */\n\tfunction ap(s2) {\n\t  var s1 = this;\n\t  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n\t}\n\t\n\t/**\n\t * Get a human readable view of a stream\n\t * @name stream.toString\n\t * @return {String} the stream string representation\n\t */\n\tfunction streamToString() {\n\t  return 'stream(' + this.val + ')';\n\t}\n\t\n\t/**\n\t * @name stream.end\n\t * @memberof stream\n\t * A stream that emits `true` when the stream ends. If `true` is pushed down the\n\t * stream the parent stream ends.\n\t */\n\t\n\t/**\n\t * @name stream.of\n\t * @function\n\t * @memberof stream\n\t * Returns a new stream with `value` as its initial value. It is identical to\n\t * calling `flyd.stream` with one argument.\n\t *\n\t * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n\t *\n\t * @param {*} value - the initial value\n\t * @return {stream} the new stream\n\t *\n\t * @example\n\t * var n = flyd.stream(1);\n\t * var m = n.of(1);\n\t */\n\t\n\t// /////////////////////////// PRIVATE ///////////////////////////////// //\n\t/**\n\t * @private\n\t * Create a stream with no dependencies and no value\n\t * @return {Function} a flyd stream\n\t */\n\tfunction createStream() {\n\t  function s(n) {\n\t    if (arguments.length === 0) return s.val\n\t    updateStreamValue(s, n)\n\t    return s\n\t  }\n\t  s.hasVal = false;\n\t  s.val = undefined;\n\t  s.vals = [];\n\t  s.listeners = [];\n\t  s.queued = false;\n\t  s.end = undefined;\n\t  s.map = boundMap;\n\t  s.ap = ap;\n\t  s.of = flyd.stream;\n\t  s.toString = streamToString;\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Create a dependent stream\n\t * @param {Array<stream>} dependencies - an array of the streams\n\t * @param {Function} fn - the function used to calculate the new stream value\n\t * from the dependencies\n\t * @return {stream} the created stream\n\t */\n\tfunction createDependentStream(deps, fn) {\n\t  var s = createStream();\n\t  s.fn = fn;\n\t  s.deps = deps;\n\t  s.depsMet = false;\n\t  s.depsChanged = deps.length > 0 ? [] : undefined;\n\t  s.shouldUpdate = false;\n\t  addListeners(deps, s);\n\t  return s;\n\t}\n\t\n\t/**\n\t * @private\n\t * Check if all the dependencies have values\n\t * @param {stream} stream - the stream to check depencencies from\n\t * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n\t */\n\tfunction initialDepsNotMet(stream) {\n\t  stream.depsMet = stream.deps.every(function(s) {\n\t    return s.hasVal;\n\t  });\n\t  return !stream.depsMet;\n\t}\n\t\n\t/**\n\t * @private\n\t * Update a dependent stream using its dependencies in an atomic way\n\t * @param {stream} stream - the stream to update\n\t */\n\tfunction updateStream(s) {\n\t  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n\t      (s.end !== undefined && s.end.val === true)) return;\n\t  if (inStream !== undefined) {\n\t    toUpdate.push(s);\n\t    return;\n\t  }\n\t  inStream = s;\n\t  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n\t  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n\t  if (returnVal !== undefined) {\n\t    s(returnVal);\n\t  }\n\t  inStream = undefined;\n\t  if (s.depsChanged !== undefined) s.depsChanged = [];\n\t  s.shouldUpdate = false;\n\t  if (flushing === false) flushUpdate();\n\t}\n\t\n\t/**\n\t * @private\n\t * Update the dependencies of a stream\n\t * @param {stream} stream\n\t */\n\tfunction updateDeps(s) {\n\t  var i, o, list\n\t  var listeners = s.listeners;\n\t  for (i = 0; i < listeners.length; ++i) {\n\t    list = listeners[i];\n\t    if (list.end === s) {\n\t      endStream(list);\n\t    } else {\n\t      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n\t      list.shouldUpdate = true;\n\t      findDeps(list);\n\t    }\n\t  }\n\t  for (; orderNextIdx >= 0; --orderNextIdx) {\n\t    o = order[orderNextIdx];\n\t    if (o.shouldUpdate === true) updateStream(o);\n\t    o.queued = false;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add stream dependencies to the global `order` queue.\n\t * @param {stream} stream\n\t * @see updateDeps\n\t */\n\tfunction findDeps(s) {\n\t  var i\n\t  var listeners = s.listeners;\n\t  if (s.queued === false) {\n\t    s.queued = true;\n\t    for (i = 0; i < listeners.length; ++i) {\n\t      findDeps(listeners[i]);\n\t    }\n\t    order[++orderNextIdx] = s;\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction flushUpdate() {\n\t  flushing = true;\n\t  while (toUpdate.length > 0) {\n\t    var s = toUpdate.shift();\n\t    if (s.vals.length > 0) s.val = s.vals.shift();\n\t    updateDeps(s);\n\t  }\n\t  flushing = false;\n\t}\n\t\n\t/**\n\t * @private\n\t * Push down a value into a stream\n\t * @param {stream} stream\n\t * @param {*} value\n\t */\n\tfunction updateStreamValue(s, n) {\n\t  if (n !== undefined && n !== null && isFunction(n.then)) {\n\t    n.then(s);\n\t    return;\n\t  }\n\t  s.val = n;\n\t  s.hasVal = true;\n\t  if (inStream === undefined) {\n\t    flushing = true;\n\t    updateDeps(s);\n\t    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n\t  } else if (inStream === s) {\n\t    markListeners(s, s.listeners);\n\t  } else {\n\t    s.vals.push(n);\n\t    toUpdate.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t */\n\tfunction markListeners(s, lists) {\n\t  var i, list;\n\t  for (i = 0; i < lists.length; ++i) {\n\t    list = lists[i];\n\t    if (list.end !== s) {\n\t      if (list.depsChanged !== undefined) {\n\t        list.depsChanged.push(s);\n\t      }\n\t      list.shouldUpdate = true;\n\t    } else {\n\t      endStream(list);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Add dependencies to a stream\n\t * @param {Array<stream>} dependencies\n\t * @param {stream} stream\n\t */\n\tfunction addListeners(deps, s) {\n\t  for (var i = 0; i < deps.length; ++i) {\n\t    deps[i].listeners.push(s);\n\t  }\n\t}\n\t\n\t/**\n\t * @private\n\t * Removes an stream from a dependency array\n\t * @param {stream} stream\n\t * @param {Array<stream>} dependencies\n\t */\n\tfunction removeListener(s, listeners) {\n\t  var idx = listeners.indexOf(s);\n\t  listeners[idx] = listeners[listeners.length - 1];\n\t  listeners.length--;\n\t}\n\t\n\t/**\n\t * @private\n\t * Detach a stream from its dependencies\n\t * @param {stream} stream\n\t */\n\tfunction detachDeps(s) {\n\t  for (var i = 0; i < s.deps.length; ++i) {\n\t    removeListener(s, s.deps[i].listeners);\n\t  }\n\t  s.deps.length = 0;\n\t}\n\t\n\t/**\n\t * @private\n\t * Ends a stream\n\t */\n\tfunction endStream(s) {\n\t  if (s.deps !== undefined) detachDeps(s);\n\t  if (s.end !== undefined) detachDeps(s.end);\n\t}\n\t\n\t/**\n\t * @private\n\t * transducer stream transformer\n\t */\n\tfunction StreamTransformer() { }\n\tStreamTransformer.prototype['@@transducer/init'] = function() { };\n\tStreamTransformer.prototype['@@transducer/result'] = function() { };\n\tStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\t\n\tmodule.exports = flyd;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _curry1 = __webpack_require__(5);\n\tvar _curry2 = __webpack_require__(7);\n\tvar _curryN = __webpack_require__(8);\n\t\n\t\n\t/**\n\t * Returns a curried equivalent of the provided function, with the specified\n\t * arity. The curried function has two unusual capabilities. First, its\n\t * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1)(2)(3)`\n\t *   - `g(1)(2, 3)`\n\t *   - `g(1, 2)(3)`\n\t *   - `g(1, 2, 3)`\n\t *\n\t * Secondly, the special placeholder value `R.__` may be used to specify\n\t * \"gaps\", allowing partial application of any combination of arguments,\n\t * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n\t * following are equivalent:\n\t *\n\t *   - `g(1, 2, 3)`\n\t *   - `g(_, 2, 3)(1)`\n\t *   - `g(_, _, 3)(1)(2)`\n\t *   - `g(_, _, 3)(1, 2)`\n\t *   - `g(_, 2)(1)(3)`\n\t *   - `g(_, 2)(1, 3)`\n\t *   - `g(_, 2)(_, 3)(1)`\n\t *\n\t * @func\n\t * @memberOf R\n\t * @since v0.5.0\n\t * @category Function\n\t * @sig Number -> (* -> a) -> (* -> a)\n\t * @param {Number} length The arity for the returned function.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} A new, curried function.\n\t * @see R.curry\n\t * @example\n\t *\n\t *      var sumArgs = (...args) => R.sum(args);\n\t *\n\t *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n\t *      var f = curriedAddFourNumbers(1, 2);\n\t *      var g = f(3);\n\t *      g(4); //=> 10\n\t */\n\tmodule.exports = _curry2(function curryN(length, fn) {\n\t  if (length === 1) {\n\t    return _curry1(fn);\n\t  }\n\t  return _arity(length, _curryN(length, [], fn));\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _arity(n, fn) {\n\t  /* eslint-disable no-unused-vars */\n\t  switch (n) {\n\t    case 0: return function() { return fn.apply(this, arguments); };\n\t    case 1: return function(a0) { return fn.apply(this, arguments); };\n\t    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n\t    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n\t    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n\t    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n\t    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n\t    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n\t    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n\t    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n\t    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n\t    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n\t  }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal one-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry1(fn) {\n\t  return function f1(a) {\n\t    if (arguments.length === 0 || _isPlaceholder(a)) {\n\t      return f1;\n\t    } else {\n\t      return fn.apply(this, arguments);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function _isPlaceholder(a) {\n\t  return a != null &&\n\t         typeof a === 'object' &&\n\t         a['@@functional/placeholder'] === true;\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _curry1 = __webpack_require__(5);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Optimized internal two-arity curry function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curry2(fn) {\n\t  return function f2(a, b) {\n\t    switch (arguments.length) {\n\t      case 0:\n\t        return f2;\n\t      case 1:\n\t        return _isPlaceholder(a) ? f2\n\t             : _curry1(function(_b) { return fn(a, _b); });\n\t      default:\n\t        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n\t             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n\t             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n\t             : fn(a, b);\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _arity = __webpack_require__(4);\n\tvar _isPlaceholder = __webpack_require__(6);\n\t\n\t\n\t/**\n\t * Internal curryN function.\n\t *\n\t * @private\n\t * @category Function\n\t * @param {Number} length The arity of the curried function.\n\t * @param {Array} received An array of arguments received thus far.\n\t * @param {Function} fn The function to curry.\n\t * @return {Function} The curried function.\n\t */\n\tmodule.exports = function _curryN(length, received, fn) {\n\t  return function() {\n\t    var combined = [];\n\t    var argsIdx = 0;\n\t    var left = length;\n\t    var combinedIdx = 0;\n\t    while (combinedIdx < received.length || argsIdx < arguments.length) {\n\t      var result;\n\t      if (combinedIdx < received.length &&\n\t          (!_isPlaceholder(received[combinedIdx]) ||\n\t           argsIdx >= arguments.length)) {\n\t        result = received[combinedIdx];\n\t      } else {\n\t        result = arguments[argsIdx];\n\t        argsIdx += 1;\n\t      }\n\t      combined[combinedIdx] = result;\n\t      if (!_isPlaceholder(result)) {\n\t        left -= 1;\n\t      }\n\t      combinedIdx += 1;\n\t    }\n\t    return left <= 0 ? fn.apply(this, combined)\n\t                     : _arity(left, _curryN(length, combined, fn));\n\t  };\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n\t  'use strict';\n\t\n\t  /*istanbul ignore next:cant test*/\n\t  if (typeof module === 'object' && typeof module.exports === 'object') {\n\t    module.exports = factory();\n\t  } else if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else {\n\t    // Browser globals\n\t    root.objectPath = factory();\n\t  }\n\t})(this, function(){\n\t  'use strict';\n\t\n\t  var toStr = Object.prototype.toString;\n\t  function hasOwnProperty(obj, prop) {\n\t    if(obj == null) {\n\t      return false\n\t    }\n\t    //to handle objects with null prototypes (too edge case?)\n\t    return Object.prototype.hasOwnProperty.call(obj, prop)\n\t  }\n\t\n\t  function isEmpty(value){\n\t    if (!value) {\n\t      return true;\n\t    }\n\t    if (isArray(value) && value.length === 0) {\n\t        return true;\n\t    } else if (typeof value !== 'string') {\n\t        for (var i in value) {\n\t            if (hasOwnProperty(value, i)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function toString(type){\n\t    return toStr.call(type);\n\t  }\n\t\n\t  function isObject(obj){\n\t    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n\t  }\n\t\n\t  var isArray = Array.isArray || function(obj){\n\t    /*istanbul ignore next:cant test*/\n\t    return toStr.call(obj) === '[object Array]';\n\t  }\n\t\n\t  function isBoolean(obj){\n\t    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n\t  }\n\t\n\t  function getKey(key){\n\t    var intKey = parseInt(key);\n\t    if (intKey.toString() === key) {\n\t      return intKey;\n\t    }\n\t    return key;\n\t  }\n\t\n\t  function factory(options) {\n\t    options = options || {}\n\t\n\t    var objectPath = function(obj) {\n\t      return Object.keys(objectPath).reduce(function(proxy, prop) {\n\t        if(prop === 'create') {\n\t          return proxy;\n\t        }\n\t\n\t        /*istanbul ignore else*/\n\t        if (typeof objectPath[prop] === 'function') {\n\t          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n\t        }\n\t\n\t        return proxy;\n\t      }, {});\n\t    };\n\t\n\t    function getShallowProperty(obj, prop) {\n\t      if (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)) {\n\t        return obj[prop];\n\t      }\n\t    }\n\t\n\t    function set(obj, path, value, doNotReplace){\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t      if (!path || path.length === 0) {\n\t        return obj;\n\t      }\n\t      if (typeof path === 'string') {\n\t        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n\t      }\n\t      var currentPath = path[0];\n\t      var currentValue = getShallowProperty(obj, currentPath);\n\t      if (path.length === 1) {\n\t        if (currentValue === void 0 || !doNotReplace) {\n\t          obj[currentPath] = value;\n\t        }\n\t        return currentValue;\n\t      }\n\t\n\t      if (currentValue === void 0) {\n\t        //check if we assume an array\n\t        if(typeof path[1] === 'number') {\n\t          obj[currentPath] = [];\n\t        } else {\n\t          obj[currentPath] = {};\n\t        }\n\t      }\n\t\n\t      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n\t    }\n\t\n\t    objectPath.has = function (obj, path) {\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      } else if (typeof path === 'string') {\n\t        path = path.split('.');\n\t      }\n\t\n\t      if (!path || path.length === 0) {\n\t        return !!obj;\n\t      }\n\t\n\t      for (var i = 0; i < path.length; i++) {\n\t        var j = getKey(path[i]);\n\t\n\t        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n\t          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n\t          obj = obj[j];\n\t        } else {\n\t          return false;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    objectPath.ensureExists = function (obj, path, value){\n\t      return set(obj, path, value, true);\n\t    };\n\t\n\t    objectPath.set = function (obj, path, value, doNotReplace){\n\t      return set(obj, path, value, doNotReplace);\n\t    };\n\t\n\t    objectPath.insert = function (obj, path, value, at){\n\t      var arr = objectPath.get(obj, path);\n\t      at = ~~at;\n\t      if (!isArray(arr)) {\n\t        arr = [];\n\t        objectPath.set(obj, path, arr);\n\t      }\n\t      arr.splice(at, 0, value);\n\t    };\n\t\n\t    objectPath.empty = function(obj, path) {\n\t      if (isEmpty(path)) {\n\t        return void 0;\n\t      }\n\t      if (obj == null) {\n\t        return void 0;\n\t      }\n\t\n\t      var value, i;\n\t      if (!(value = objectPath.get(obj, path))) {\n\t        return void 0;\n\t      }\n\t\n\t      if (typeof value === 'string') {\n\t        return objectPath.set(obj, path, '');\n\t      } else if (isBoolean(value)) {\n\t        return objectPath.set(obj, path, false);\n\t      } else if (typeof value === 'number') {\n\t        return objectPath.set(obj, path, 0);\n\t      } else if (isArray(value)) {\n\t        value.length = 0;\n\t      } else if (isObject(value)) {\n\t        for (i in value) {\n\t          if (hasOwnProperty(value, i)) {\n\t            delete value[i];\n\t          }\n\t        }\n\t      } else {\n\t        return objectPath.set(obj, path, null);\n\t      }\n\t    };\n\t\n\t    objectPath.push = function (obj, path /*, values */){\n\t      var arr = objectPath.get(obj, path);\n\t      if (!isArray(arr)) {\n\t        arr = [];\n\t        objectPath.set(obj, path, arr);\n\t      }\n\t\n\t      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n\t    };\n\t\n\t    objectPath.coalesce = function (obj, paths, defaultValue) {\n\t      var value;\n\t\n\t      for (var i = 0, len = paths.length; i < len; i++) {\n\t        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n\t          return value;\n\t        }\n\t      }\n\t\n\t      return defaultValue;\n\t    };\n\t\n\t    objectPath.get = function (obj, path, defaultValue){\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t      if (!path || path.length === 0) {\n\t        return obj;\n\t      }\n\t      if (obj == null) {\n\t        return defaultValue;\n\t      }\n\t      if (typeof path === 'string') {\n\t        return objectPath.get(obj, path.split('.'), defaultValue);\n\t      }\n\t\n\t      var currentPath = getKey(path[0]);\n\t      var nextObj = getShallowProperty(obj, currentPath)\n\t      if (nextObj === void 0) {\n\t        return defaultValue;\n\t      }\n\t\n\t      if (path.length === 1) {\n\t        return nextObj;\n\t      }\n\t\n\t      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n\t    };\n\t\n\t    objectPath.del = function del(obj, path) {\n\t      if (typeof path === 'number') {\n\t        path = [path];\n\t      }\n\t\n\t      if (obj == null) {\n\t        return obj;\n\t      }\n\t\n\t      if (isEmpty(path)) {\n\t        return obj;\n\t      }\n\t      if(typeof path === 'string') {\n\t        return objectPath.del(obj, path.split('.'));\n\t      }\n\t\n\t      var currentPath = getKey(path[0]);\n\t      var currentVal = getShallowProperty(obj, currentPath);\n\t      if(currentVal == null) {\n\t        return currentVal;\n\t      }\n\t\n\t      if(path.length === 1) {\n\t        if (isArray(obj)) {\n\t          obj.splice(currentPath, 1);\n\t        } else {\n\t          delete obj[currentPath];\n\t        }\n\t      } else {\n\t        if (obj[currentPath] !== void 0) {\n\t          return objectPath.del(obj[currentPath], path.slice(1));\n\t        }\n\t      }\n\t\n\t      return obj;\n\t    }\n\t\n\t    return objectPath;\n\t  }\n\t\n\t  var mod = factory();\n\t  mod.create = factory;\n\t  mod.withInheritedProps = factory({includeInheritedProps: true})\n\t  return mod;\n\t});\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// meiosis.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bf8ce819239bd3bcfaa8","export * from \"./meiosis\";\nexport * from \"./component\";\nexport * from \"./initialModel\";\nexport * from \"./nextAction\";\nexport * from \"./receive\";\nexport * from \"./state\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import * as flyd from \"flyd\";\nimport * as objectPath from \"object-path\";\nimport { Component } from \"./component\";\nimport { InitialModel } from \"./initialModel\";\nimport { Receive } from \"./receive\";\nimport { ComponentState, State } from \"./state\";\nimport { NextAction } from \"./nextAction\";\n\ntype Stream<T> = Flyd.Stream<T>;\n\nexport interface RunParameters<M, P, S> {\n  initialModel: M;\n  components: Array<Component<M, P, S>>;\n}\n\nexport interface MeiosisRun<M, P, S> {\n  (params: RunParameters<M, P, S>): MeiosisApp<M, P, S>;\n}\n\nexport interface MeiosisInstance<M, P, S> {\n  propose: Flyd.Stream<P>;\n  run: MeiosisRun<M, P, S>;\n}\n\nexport interface MeiosisApp<M, P, S> {\n  model: Flyd.Stream<M>;\n  stateFn: State<M, S>;\n  state: Flyd.Stream<S>;\n}\n\nconst copy = (obj: any): any => JSON.parse(JSON.stringify(obj));\nconst prop = (property: string) => (value: any) => value[property];\nconst identity = <T>(value: T) => value;\n\nfunction newInstance<M, P, S>(): MeiosisInstance<M, P, S> {\n  const propose: Stream<P> = flyd.stream<P>();\n\n  const run = (params: RunParameters<M, P, S>): MeiosisApp<M, P, S> => {\n    if (!params.initialModel || !params.components) {\n      throw new Error(\"Please specify initialModel and components.\");\n    }\n    const getComponentFunctions = <M, P, S>(property: string, components: Array<Component<M, P, S>>) =>\n      components.map(prop(property)).filter(identity);\n\n    const addAllComponents = <M, P, S>(components: Array<Component<M, P, S>>, list: Array<Component<M, P, S>>) => {\n      const children: Array<Component<M, P, S>> = list || [];\n      children.forEach(child => {\n        components.push(child);\n        addAllComponents(components, child.components);\n      });\n    };\n\n    const components: Array<Component<M, P, S>> = [];\n    addAllComponents(components, params.components);\n\n    const initialModels: Array<InitialModel<M>> = getComponentFunctions(\"initialModel\", components);\n    const initialModel: M = initialModels.reduce((model, fn) => fn(model), params.initialModel);\n\n    const receives: Array<Receive<M, P>> = getComponentFunctions(\"receive\", components);\n    const receive: Receive<M, P> = (model: M, proposal: P) =>\n      receives.reduce((model, fn) => fn(model, proposal), model);\n\n    const model: Stream<M> = flyd.scan<P, M>(receive, initialModel, propose);\n\n    const states: Array<ComponentState<M, S>> = getComponentFunctions(\"state\", components);\n    const stateFn: State<M, S> = (model: M) =>\n      states.reduce((state, fn) => fn(model, state), copy(model));\n\n    const state: Stream<S> = flyd.map<M, S>(stateFn, model);\n\n    const nexts: Array<NextAction<M, P>> = getComponentFunctions(\"nextAction\", components);\n    const nextAction: NextAction<M, P> = (model: M, proposal: P) => nexts.forEach(fn => fn(model, proposal));\n\n    flyd.on(model => propose() && nextAction(model, propose()), model);\n\n    return {\n      model,\n      stateFn,\n      state\n    };\n  };\n\n  return {\n    propose,\n    run\n  };\n}\n\nexport interface NestComponent {\n  component: Component<any, any, any>;\n  path: string;\n}\n\nfunction nestComponent(params: NestComponent): Component<any, any, any> {\n  const component: Component<any, any, any> = params.component;\n  const path: string = params.path;\n\n  const nested: Component<any, any, any> = {\n    initialModel: component.initialModel,\n    components: component.components,\n    receive: component.receive && ((model: any, proposal: any) => {\n      const subModel: any = objectPath.get(model, path);\n\n      if (subModel) {\n        component.receive(subModel, proposal);\n      }\n      return model;\n    }),\n    nextAction: component.nextAction && ((model: any, proposal: any) => {\n      const subModel: any = objectPath.get(model, path);\n\n      if (subModel) {\n        component.nextAction(subModel, proposal);\n      }\n    }),\n    state: component.state && ((model: any, state: any) => {\n      const subModel: any = objectPath.get(model, path);\n      const subState: any = objectPath.get(state, path);\n\n      if (subModel && subState) {\n        objectPath.set(state, path, component.state(subModel, subState));\n      }\n      return state;\n    })\n  };\n  return nested;\n}\n\nexport interface ComponentContainer<M, P, S> {\n  component: Component<M, P, S>;\n  getComponents: (model: M) => Array<Component<M, P, S>>;\n}\n\nfunction componentContainer<M, P, S>(params: ComponentContainer<M, P, S>): Component<M, P, S> {\n  const container: Component<M, P, S> = {\n    initialModel: params.component.initialModel,\n    components: params.component.components,\n    receive: (model: M, proposal: P) => {\n      params.component.receive && params.component.receive(model, proposal);\n      params.getComponents(model).forEach((child: Component<M, P, S>) => child.receive && child.receive(model, proposal));\n      return model;\n    },\n    state: (model: M, state: S) => {\n      params.component.state && params.component.state(model, state);\n      params.getComponents(model).forEach((child: Component<M, P, S>) => child.state && child.state(model, state));\n      return state;\n    },\n    nextAction: (model: M, proposal: P) => {\n      params.component.nextAction && params.component.nextAction(model, proposal);\n      params.getComponents(model).forEach((child: Component<M, P, S>) => child.nextAction && child.nextAction(model, proposal));\n    }\n  };\n  return container;\n}\n\nconst instance = newInstance<any, any, any>();\nconst propose = instance.propose;\nconst run = instance.run;\n\nexport {\n  Stream,\n  newInstance,\n  propose,\n  run,\n  nestComponent,\n  componentContainer\n};\n\nexport const { combine, map, merge, on, scan } = flyd;\n\n\n\n// WEBPACK FOOTER //\n// ./src/meiosis.ts","'use strict';\n\nvar curryN = require('ramda/src/curryN');\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushing = false;\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nflyd.map = curryN(2, function(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n})\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return flyd.map(f, this); }\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stram with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2) {\n  var s1 = this;\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(s, n)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.vals = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n  s.map = boundMap;\n  s.ap = ap;\n  s.of = flyd.stream;\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDepsNotMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return !stream.depsMet;\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if ((s.depsMet !== true && initialDepsNotMet(s)) ||\n      (s.end !== undefined && s.end.val === true)) return;\n  if (inStream !== undefined) {\n    toUpdate.push(s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing === false) flushUpdate();\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateDeps(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushing = true;\n  while (toUpdate.length > 0) {\n    var s = toUpdate.shift();\n    if (s.vals.length > 0) s.val = s.vals.shift();\n    updateDeps(s);\n  }\n  flushing = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(s, n) {\n  if (n !== undefined && n !== null && isFunction(n.then)) {\n    n.then(s);\n    return;\n  }\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushing = true;\n    updateDeps(s);\n    if (toUpdate.length > 0) flushUpdate(); else flushing = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    s.vals.push(n);\n    toUpdate.push(s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/flyd/lib/index.js\n// module id = 2\n// module chunks = 0","var _arity = require('./internal/_arity');\nvar _curry1 = require('./internal/_curry1');\nvar _curry2 = require('./internal/_curry2');\nvar _curryN = require('./internal/_curryN');\n\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value `R.__` may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is `R.__`, the\n * following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nmodule.exports = _curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/curryN.js\n// module id = 3\n// module chunks = 0","module.exports = function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0: return function() { return fn.apply(this, arguments); };\n    case 1: return function(a0) { return fn.apply(this, arguments); };\n    case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_arity.js\n// module id = 4\n// module chunks = 0","var _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry1.js\n// module id = 5\n// module chunks = 0","module.exports = function _isPlaceholder(a) {\n  return a != null &&\n         typeof a === 'object' &&\n         a['@@functional/placeholder'] === true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_isPlaceholder.js\n// module id = 6\n// module chunks = 0","var _curry1 = require('./_curry1');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2\n             : _curry1(function(_b) { return fn(a, _b); });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })\n             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n             : fn(a, b);\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curry2.js\n// module id = 7\n// module chunks = 0","var _arity = require('./_arity');\nvar _isPlaceholder = require('./_isPlaceholder');\n\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nmodule.exports = function _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length &&\n          (!_isPlaceholder(received[combinedIdx]) ||\n           argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined)\n                     : _arity(left, _curryN(length, combined, fn));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ramda/src/internal/_curryN.js\n// module id = 8\n// module chunks = 0","(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    function getShallowProperty(obj, prop) {\n      if (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasOwnProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      var currentVal = getShallowProperty(obj, currentPath);\n      if(currentVal == null) {\n        return currentVal;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        if (obj[currentPath] !== void 0) {\n          return objectPath.del(obj[currentPath], path.slice(1));\n        }\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-path/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}